var documenterSearchIndex = {"docs":
[{"location":"tests.html#Tests-and-examples-provided","page":"Examples","title":"Tests and examples provided","text":"","category":"section"},{"location":"tests.html#Try-it-yourself!","page":"Examples","title":"Try it yourself!","text":"","category":"section"},{"location":"tests.html","page":"Examples","title":"Examples","text":"We have included a couple of scripts so you can test that CALiPPSO is working properly. All of them are contained in the Examples folder, so be sure to cd into it before executing the commands below. Besides, be sure to have installed all the required dependencies and as well as the solvers you want to test.","category":"page"},{"location":"tests.html","page":"Examples","title":"Examples","text":"Besides, consider that the main function is defined in the file CALiPPSO.jl, so this file should be included in any script where produce_jammed_configuration! is called (with the usual syntax include(\"CALiPPSO.jl\")). Now, when this script is first called through include, you'll see a rather long output printed out. As its first line explains, this is because a first compilation is being carried out, but you can safely ignore all of such output.","category":"page"},{"location":"tests.html#Some-examples-included","page":"Examples","title":"Some examples included","text":"","category":"section"},{"location":"tests.html","page":"Examples","title":"Examples","text":"We provide the following examples to test our algorithm under different circumstances","category":"page"},{"location":"tests.html","page":"Examples","title":"Examples","text":"Testing CALiPPSO from a highly compressed configuration of N=1204 particles (obtained from the LS protocol) in d=3 4 5.\nTo execute this test, simply execute from the terminal  julia test-monodisperse-after-LS.jl\nFor running this script, you'll need to have the (included) files Centers-after-LS--N-1024--d-3.dat, etc. in the same folder.\nTesting CALiPPSO from a random, low density initial configuration of N=512 particles, in d=2345.\nSimilarly, you'll need to type   julia test-monodisperse-random_init_conf.jl\nThis script does not depend on any input file as initial condition. But be sure to have the Distributions.jl package already installed.","category":"page"},{"location":"tests.html#Testing-different-solvers","page":"Examples","title":"Testing different solvers","text":"","category":"section"},{"location":"tests.html","page":"Examples","title":"Examples","text":"Testing CALiPPSO with different solvers.\nFor running this test, type:    julia tests-different-solvers.jl \nFor simplicity the same initial condition is given in all cases, namely Centers-after-LS--N-1024--d-3.dat, but if you want to use the analogous files corresponding to different dimensions, you just need to change the value of d in the tests-different-solvers.jl file.\nAs it is, this test is meant to work with the solvers mentioned above, i.e. Gurobi, HiGHS, GLPK, Clp, Hypatia, and COSMO. So be sure to have installed all of them or, in any case, delete the corresponding entries of the missing ones from  the arrays solvers, solvers_attributes, and solvers_args defined in tests-different-solvers.jl.\nIf you want to add another solver, or change the default options, be sure to read the changing the solver/optimizer section above.","category":"page"},{"location":"tests.html","page":"Examples","title":"Examples","text":"In all cases, verbose has been set to true, so you can see al the provided info about the progress and convergence status of CALiPPSO directly from the terminal.","category":"page"},{"location":"tests.html#A-simple-example-and-understanding-the-output","page":"Examples","title":"A simple example and understanding the output","text":"","category":"section"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Naturally, the first thing is to have Julia installed in your system. Afterwards, you can add CALiPPSO.jl package using the Julia's package manager. However, CALiPPSO is not yet registered in Julia Registries (but we are working to make it so). Therefore, you'll need to add it from the GitHub repo:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/rdhr/CALiPPSO.jl.git\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This should also install the required dependencies, of which a very important one is GLPK, because it is the default solver of CALiPPSO. In any case, once added, you can simply import CALiPPSO into your current working space (i.e. the REPL, a Jupyter notebook, script, etc) as any other package, namely using CALiPPSO. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"note: Default solver\nWe chose GLPK as the default solver in our package mainly because its Julia package can be easily installed, and thus is a \"safe\" dependency. However, we suggest using another, more performant solver for large systems. In this section we explain how to choose the solver used by CALiPPSO.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"If you have everything set up, you can jump to the Basic usage section.","category":"page"},{"location":"installation.html#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"All the dependencies should be downloaded and installed once you add CALiPPSO. However, as mentioned above, its default solver is GNU Linear Programming Kit(a.k.a. GLPK). This solver has been amply tested, but is not really performant compared to more modern options. Thus, we suggest to use a different solver if you are going to use CALiPSSO for systems of, say, N 2000 particles.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"We have mostly tested our algorithm with the Gurobi optimizer, naturally using it through its Julia package: Gurobi.jl.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"note: Installing Gurobi\nGurobi requires manual installation. This means that, before adding Gurobi.jl via the Julia's package manager, you need to have Gurobi properly installed in your system. Once you've downloaded Gurobi's latest version, follow the installation instructions of your operative system. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Note that Gurobi is a licensed solver, but a free license is available for academic use. \nConsider also that, of the different solvers we tested, we observed that Gurobi is clearly the most performant and accurate solver, so we do recommend using these scripts in combination with it for more precise results.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"In any case, see the choosing another solver for instructions on how to use another (hopefully open-sourced) optimizer. Our implementation already includes working code for these other solvers: HiGHS.jl, Clp.jl, Hypatia.jl, and COSMO.jl. However, you'll need to install them separately. Fortunately, any (or all) of them are readily available from Julia's package manager interface, i.e. using Pkg; Pkg.add(\"<solver of your choice>\") for a single one, or","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"HiGHS\", \"GLPK\", \"Clp\", \"Hypatia\", \"COSMO\"])","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"for adding all of them simultaneously. This latter option might be useful if you want to run the tests described using different solvers.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"warning: Issue with COSMO and Hypatia\nIn our tests we observed that while our code runs without any errors using both COSMO and Hypatia solvers, the packing obtained maybe either non-isostatic or the contact forces differ significantly from the ones found using the other solvers. We think that this is due to a lower precision in the solutions obtained by these solvers.If this is the case, it is likely that this issue can be easily solved by a correct tunning of the solvers' parameters. We were not able to find such good combination, but we did not try much. So if you have any ideas or can help us, please contact us","category":"page"},{"location":"basic_usage.html#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basic_usage.html#The-main-function:-produce_jammed_configuration!","page":"Basic usage","title":"The main function: produce_jammed_configuration!","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"We tried to make this package as easy to use as possible and, indeed, it consists of a single main function: produce_jammed_configuration!. This function is defined in the CALiPPSO module, contained in the CALiPPSO.jl file. Thus, to include produce_jammed_configuration! in your scope or Julia script, you need to add the following lines to your script, REPL, Jupyter Notebook, etc.:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using CALiPPSO  ","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"In this way, produce_jammed_configuration! as well as other functions and struct's will be loaded into your environment. The additional functions that are exported when loading CALiPPSO (such as network_of_contacts, check_for_overlaps, get_non_rattlers, etc.) are not needed for a basic usage, but might be useful for analysing the packings produced by the main function. ","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Once CALiPPSO has been loaded, you just need to call","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"packing, info, Γ_vs_t, Smax_vs_t, isostatic_vs_t = produce_jammed_configuration!(Xs, R, L)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Naturally, this function should generate a jammed packing from an initial (monodisperse) configuration of particles with positions Xs, radius R, and contained in a periodic (hyper-) cube of size L (if this argument is left unspecified, it's assumed its value is 1). Xs should be a Matrix{Float64} of size dtimes N, thus specifying the position of each particle (i.e. each of the N columns is the d-dimensional position vector of a particle). Clearly, this matrix can be constructed from importing data from a csv or dat file (or any other suitable file format for that matter).","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Alternatively, Xs might be an array of N StaticVectors, each of size d and elements of PeriodicNumber type (see here for the dedicated section on types). In such case, L should be omitted when calling produce_jammed_configuration!, because its value  automatically inferred from the corresponding field of PeriodicNumber. For convenience, if Xs is a matrix of Float64 elements (i.e. a Matrix{Float64} type), it can be easily converted to an array of StaticVectors with PeriodicNumber elements using the PeriodicVectors function. Thus, the analogous version of the code above reads","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Xs = PeriodicVectors(Xs, L)\npacking, info, Γ_vs_t, Smax_vs_t, isostatic_vs_t = produce_jammed_configuration!(Xs, R)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Note that here we are making use of the method dispatch feature of Julia.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Of course, these last examples assume  that you are already given a valid configuration that can be used as initial condition. If this is not the case, or  you want to use a random, low-density initial configuration as input to CALiPSSO, you can use generate_random_configuration, which is also loaded when importing CALiPPSO. Thus a MWE would be the following","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using CALiPPSO  \nprecompile_main_function() #optional, but highly recommended. This will produce a colorful output that you can safely ignore\nusing Random\nRandom.seed!(123) # optional, but just for reproducibility sake of this MWE\n# Choosing the seed of the Julia's RNG determines the random IC produces below with `generate_random_configuration`\n\nconst d, N, φ0, L = 3, 512, 0.3, 1.0\nR, Xs = generate_random_configuration(d, N, φ0, L) # if L is not passed, it's assumed that the systems is in a box of size 1\n\npacking, info, Γ_vs_t, Smax_vs_t, isostatic_vs_t = produce_jammed_configuration!(Xs, R; \n            ℓ0=0.3*L, non_iso_break=50, max_iters=500)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"note: Precompilation\nprecompile_main_function() calls produce_jammed_configuration! on a small, predefined system. (It will also produce a colorful output that you can safely ignore.) Thus, the main function will be pre-compiled and ready to use in larger and more demanding systems.Calling precompile_main_function() is optional, but strongly suggested if you want to use CALiPPSO for producing jammed packings (i.e. if at any point you call produce_jammed_configuration!). However, it you only use CALiPPSO for analysing packings previously produced there's no need for precompiling.The reason why avoiding precompilation is discouraged is that model creation and optimization in JuMP suffers from a \"time-to-first-solve\" issue, which is an analogous version of the \"time-to-first-plot\" one. Essentially, when a function is first called, it needs to be compiled. (This is actually the general behaviour of Julia, not only of JuMP.) Thus, by calling produce_jammed_configuration! in a small system, the function gets pre-compiled and ready to be used in much larger systems. If precompile_main_function() is not called, and produce_jammed_configuration! is used directly in the (presumably large) configuration you want to jam it could take much longer.","category":"page"},{"location":"basic_usage.html#Output","page":"Basic usage","title":"Output","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Using the variables introduced in the snippets above, the output of produce_jammed_configuration! is the following:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"packing: A jammed packing (provided convergence was attained) stored as a MonoPacking object (actually a struct). \nThis object contains an array of the N particles in the packing.\nEach particle is stored as a MonoParticle object that contains: (i) the position of the centre; (ii) the list of all contact vectors; (iii) the list of contact forces magnitudes; and (iv) the list of neighbours in contact.\nThe radius of all the (hyper-) spheres in the packing.\nInformation of whether (i) the packing satisfies mechanical equilibrium (stored as a boolean in the mechanical_equilibrium field), and (ii) whether the packings reached jamming or not (also as a boolean specified using the jammed field).\ninfo: Information about the process and termination status of CALiPPSO, e.g., number of iterations, the time and amount of memory allocated during the full process, list of times of each LP optimization, etc. All of this is stored using a convergence_info object.\nΓ_vs_t: The list of values of sqrtGamma^star obtained after each iteration; see the theory section for more information.\nSmax_vs_t: The list of values of max_imu s_imu^star_i=1dotsN^mu=1dotsd obtained after each iteration; see the theory section for more information.\nisostatic_vs_t: An analogous list that specifies (with boolean variables) if isostaticity holds at after each iteration.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"With its default parameters and assuming you're using Gurobi, produce_jammed_configuration! should work in most of the cases with d2 (at least we didn't experienced any error in the tests we ran), specially when p1000 (i.e. for high pressures, or varphi_0lesssim varphi_J). ","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"tip: Initial condition at low pressure\nIf the input configuration is not sufficiently compressed, a simple fix is to increase the cutoff distance used to build the neighbours-list, ell. This parameter is conveniently fixed using a keyword argument, namely, ℓ0. For instance, tryproduce_jammed_configuration!(Xs, R, L; ℓ0=0.2*L)Of course, you should choose the initial value of ell, here specified by ℓ0, taking into account the initial size of your particles and initial density of the system.  See section about The initial conditions for more information about how to choose the initial configuration of CALiPPSO.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"warning: Check the packing produced by `produce_jammed_configuration!`\nIn general situations, however, be warned that even if produce_jammed_configuration! terminates without throwing any error, it may happen that the output is not a jammed packing. For instance, it might be the case that the function terminated because the maximal number of iterations was reached, or too many consecutive non-isostatic configurations were obtained (you can tune these and several other parameters using keyword arguments, as we explain in detail in the dedicated section). This problematic situation is much likelier when varphi_0 ll varphi_J. We also observe that it may also occur using other solvers instead of Gurobi.Therefore, be sure to verify that the mechanical_equilibrium and jammed fields of the MonoPacking obtained are both true.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Finally, see this section for some examples/tests of its usage and the section on keyword arguments to fine tune the behaviour of produce_jammed_configuration! to better suit your needs.","category":"page"},{"location":"basic_usage.html#Understanding-the-output-printed-in-screen/IO","page":"Basic usage","title":"Understanding the output printed in screen/IO","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"What follows assumes that the optional argument verbose is set to true when calling produce_jammed_configuration!; this is the default behaviour. Besides, if Julia is executed with the color flag and the IO supports it, the screen output is colorized and formatted to improve readability.","category":"page"},{"location":"basic_usage.html#output-process","page":"Basic usage","title":"Output while produce_jammed_configuration! is being executed","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"When produce_jammed_configuration! is running every few iterations an output as the following one will be printed in the IO. (See here for information about how often such output appears and how to change it.)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"L1: Iteration: 3\nL2: LP instance generated with (ℓ, ℓ/R) = [0.056951385144839745, 2.7]\t and bound on (|s_i|, |s_i|/R) = [0.00021093105609199902, 0.01]\nL3: Status: OPTIMAL; \t time solve LP instance (s) = 246.3279\nL4: \t Optimal values: \t √Γ-1 = 2.4037438706159264e-11,\t max |sᵢ| (all particles) = 0.0002109310561\nL5: \t Max |sᵢ| (stable particles) = 1.0872115e-6\nL6: New  values of (φ, R) = [0.644065639, 0.021093106]\nL7: (Max, mean±std) constraints per particle per d: [15.0, 6.26, 3.93]\t Isostatic: true\t (Mean, Max, total in rattlers) z = [5.99975, 10.0, 0.0]\tNon_rattlers= 16014\nL8: ----------------------------------\nL9: Force mismatch = 1.2233477227728374e-13\nL10: Sample of smallest forces = \t[7.760517298819059e-7, 2.234495573171305e-6, 2.6928245176732605e-6, 2.7135404241734017e-6, 2.9159812742335627e-6, 3.1959098781771576e-6, 3.49862463912623e-6, 4.6744303036469655e-6, 7.2161329676828645e-6, 1.0484921226842317e-5]","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Note: The line numbers (on the left) are only included here for reference, but are not printed.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"The contents are:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Line 1: The number of CALiPPSO iteration (i.e. how many LP optimizations have been carried out).\nLines 2-4: Some information about how the LP instance (Eq. (2) in the Theory-behind-CALiPPSO section) was generated. This output is actually produced when calling solve_LP_instance in the main loop of produce_jammed_configuration!. More specifically:\nLine 2: Values of ell and bound on the displacements, s_bound, and their comparison with the particles' radius, R. Note that the value of R is taken from the previous iteration, i.e. the one used to formulate the LP instance.\nLine 3: Status of the solution of the LP problem obtained with the solver chosen, and time (in seconds) required to solve such problem. The status informs on whether the LP instance was solved to optimality or not. In other words, it the optimizer converged to a solution. \nOne reason optimality might not be attained, for instance, is that the iteration or time limits of a given solver are reached. Besides, depending on which solver you are using, you can also get information about the infeasibility of the problem, presence of duality gap, etc.\nLine 4: The optimal value of the inflation factor, Gamma^star (actually sqrtGamma^star-1), and the largest magnitude of the optimal displacements, max   mathbfs_i^star_i=1^N. \nNote: when computing this second quantity, all the particles are considered. Thus, it is very likely that the value reported correspond to mathbfs^star of a rattler. Because this particles are mostly unconstrained by their neighbours, specially during the first iterations, their value of mathbfs^star might saturate s_{bound}. Indeed, compare these two values in the example output above.\nLine 5: Largest magnitude of optimal displacements, bot now only stable particles are considered.\nLine 6: Values of the packing fraction, varphi, and particles' radius R, updated after Gamma^star has been found.\nLine 7: \nStatistics (maximum value, mean and standard deviation) of the number of constraints induced per particle.\nWhether the solution of the LP instance yielded an isostatic configuration or not.\nMean and maximum number of (possibly linear) contacts in stable particles; as well as the total number of contacts associated to rattlers.\nAmount of non-rattlers.\nLine 8: separator\nLine 9: The mismatch of the force balance condition, measured as the largest total force vector. That is, the sum of forces acting on each particle is computed for all of them, and the reported value is the vector of largest magnitude.\nLine 10: Sample of the 10 smallest forces magnitudes present in the configuration. (Note that before convergence is reached, these are not true contact forces.)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Lines 5-10 are the output of print_monitor_progress, called during the main loop of produce_jammed_configuration!, at fixed intervals. Importantly, if verbose=false is passed to produce_jammed_configuration!, none of this output will be printed.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"As explained later, the information of this output is very useful for problem solving, or at least identifying when an issue arises in a given configuration.","category":"page"},{"location":"basic_usage.html#Output-when-produce_jammed_configuration!-converges","page":"Basic usage","title":"Output when produce_jammed_configuration! converges","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"When produce_jammed_configuration! terminates, because the convergence criteria are met, the following output is given.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"L1:\t    CALiPPSO converged!\nL2: Iterations to convergence = 61,\t√Γ-1 = -2.4424906541753444e-15,\t Max displacement = 4.5795e-11,\t (ϕ, R) = [0.64414472, 0.02109397]\nL3: \tNon_rattlers= 16000\t% of rattlers = 2.344\t(Max, mean±std) constraints per particle per d: [15.0, 6.26, 3.94]\nL4: ┌ Warning: Force balance condition is NOT satisfied! Max force mismatch = 3.714346582469644e-12 ; \tCreating the packing anyway.\nL5: └ @ Main <path-to-CALiPPSO-source-folder>/Packing.jl:185\nL6:\nL7: Force balance condition not met yet; max force mismatch = 3.714346582469644e-12\nL8: Performing a last LP optimization to improve force balance.\nL9: LP instance generated with (ℓ, ℓ/R) = [0.056953715966077116, 2.7]\t and UNbounded displacements\nL10: Max optimal displacement = 3.515092848501867e-10\t √Γ-1 = 7.327471962526033e-15\nL11: Force mismatch after final optimization = 2.3502518894751413e-13\nL12:\nL13:\nL14: Isostaticity achieved: true\t Non-rattlers = 16000\t% of rattlers = 2.344\tN_contacts = 47998.0\t z in rattlers = 0\nL15: Maximum force equilibrium mismatch = 2.3502518894751413e-13\nL16: Time to finish = 299.49 minutes;\t Memory allocated (GB): 293.17\nL17: Checking for overlaps after convergence...\nL18: No overlaps found! :D","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Note: The line numbers (on the left) are only included here for reference, but are not printed.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Lines 1-3, and 17-18 are always printed (because print_converged and check_for_overlaps are always called), while the rest of the text is only provided if verbose=true is used as argument of the main function. They contain the following information:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Line 1: Text indicating that CALiPPSO did converge.\nLine 2: Information about convergence; specifically:\nNumber of LP optimizations required for convergence\nValues of sqrtGamma^star-1 and max   mathbfs_i^star_i=1^N (only of stable particles) obtained in the last iteration. These values are important because they define the convergence criteria of produce_jammed_configuration!.\nFinal values of the packing fraction and radius, varphi and R.\nLine 3: Amount of non-rattlers (i.e. stable particles) and their percentage out of N. Besides, provides the same statistics of the constraints per particle as Line 7 above.\nLines 4-13: These lines are not present in general. Instead, they will only be printed if mechanical equilibrium of the final configuration is not met (or is satisfied with a very low accuracy).\nBy far the most common reason this happens is because the bounds imposed on mathbfs_i_i=1^N, when calling solve_LP_instance. As we explain in our paper, a simple solution is to use such final configuration to generate a final LP instance and solve it, without any bounds on the displacements. Thus,\nLines 4-5: A warning thrown by the MonoPacking constructor when creating the packing. They indicate, precisely, that the force balance condition is not met and give the maximal violation to it.\nLines 7-11: The result of solving final LP instance to attain force balance with a higher accuracy. They print some info, such as the new values of Gamma^star,  max   mathbfs_i^star_i=1^N, new value of force balance mismatch, etc. They are printed when fine_tune_forces! is called. More details about this can be found in the documentation about Creating the final packing.\nLines 14-16: They provide some extra information about the packing obtained after convergence, such as whether isostaticity was reached or not; number of contacts, etc. They are printed through print_info_convergence\nLines 17-18: Check for overlaps in the final packing; printed when calling check_for_overlaps.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"warning: Mechanical equilibrium not satisfied\nAs mentioned above when explaining Lines 4-13, the likeliest reason a packing that fails to satisfy mechanical equilibrium is small mismatch (about 10^-10 or smaller) in foce balance. However, it may also happen that a configuration indeed fails to fulfil force balance due to a poor solution of an LP instance. When this is the case, the error is much bigger (about 10^-2or even larger) and even calling fine_tune_forces! is not enough to correct for it. In fact, in this situation, force balance is violated at many iterations and not only the last one. (See Lines 9-10 of the previous section.)As described in the Problem solving section, there are a variety of reason why this may happen. But the most probable one, at least according to our experience, is that the optimizer used lacks the precision to solve the linear optimization problems.","category":"page"},{"location":"basic_usage.html#Output-when-produce_jammed_configuration!-*fails*-to-converge","page":"Basic usage","title":"Output when produce_jammed_configuration! fails to converge","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"TO BE ADDED","category":"page"},{"location":"basic_usage.html#Some-other-features","page":"Basic usage","title":"Some other features","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"The dimensionality of the system is inferred from Xs and the periodic boundary conditions are automatically implemented through the usage of PeriodicNumber. Of course: no overlap should be present in the initial configuration for CALiPPSO to run properly. \nYou can (or at least should be able to) use as input any valid hard-sphere configuration generated from your favourite method (for instance, the Lubachevsky─Stillinger (LS) compression protocol as described before).\nAlternatively, you can also use the function generate_random_configuration(d, N, ϕ) provided here to generate a random low-density initial configuration of N particles in d dimensions with density ϕ. See however the possible caveat of initializing CALiPPSO with a configuration of low density (*i.e. far from jamming).\nAs CALiPPSO progresses, checks of the absence of overlaps are implemented automatically.\nStability and force balance checks are implemented. They are useful to track possible numerical issues after each of the LP optimizations are carried out; the details are given above and how to solve numerical issues is discussed here.\nThe cutoff or radius of influence, ell, is automatically adjusted in such a way that only nearby pairs of particles are considered when building the set of non-overlapping constraints.\nThe behaviour and other parameters of the main function can be easily controlled through keyword arguments.","category":"page"},{"location":"basic_usage.html#Getting-help","page":"Basic usage","title":"Getting help","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"We tried our best to provide complete docstrings of all the functions defined in this package. So most of the information should be available simply by calling the respective documentation (i.e. just by typing '?'). For instance, try typing ?produce_jammed_configuration! in the REPL or in a Jupyter notebook for a detailed description of this function. ","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"We also tried to leave clarifying comments throughout the code, so its functioning is easier to understand.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"If you find a problem (e.g. lack of convergence of the main function, low precision, non-isostaticity of the packings), please consult the Problem solving section.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Still there is something confusing ot not clear enough? Found a bug or an issue? Please drop us an email.","category":"page"},{"location":"api.html#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"api.html#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"PeriodicNumber\nMonoParticle{d,T}\nMonoPacking{d,T}\nconvergence_info","category":"page"},{"location":"api.html#CALiPPSO.PeriodicNumber","page":"API Reference","title":"CALiPPSO.PeriodicNumber","text":"PeriodicNumber{T}(value::T, L::T)\n\nDefine a number whose value is always contained between 0 and L; more precisely ∈ [0,L).\n\nWhen it is initialized with value>L or value<0 the value is transformed to be its L-modulus.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALiPPSO.MonoParticle","page":"API Reference","title":"CALiPPSO.MonoParticle","text":"MonoParticle{d, T}\n\nStruct used to construct a particle in a d-dimensional space. \n\nIt's meant to be used as components of monodisperse packings. Hence, while many of its  relevant properties are stored, its radius is instead stored in a field in 'MonoPacking' type.\n\nThe quantities this struct has are:\n\nX: The particle's center (as a StaticVector{d, PeriodicNumber{T}}})\ncontact_vecs: The set of contact vectors with the particle's neighbours (as a Vector containing SVector{d,T})\nforces: The magnitude of contact forces (Vector{T})\nneighbours: The indices of the particle's neighbours (as Vector{Int64})\n\nNaturally, 'contact_vecs', 'forces', and 'neighbours' have the same length.\n\nSee also: MonoPacking.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALiPPSO.MonoPacking","page":"API Reference","title":"CALiPPSO.MonoPacking","text":"MonoPacking{d,T}\n\nStructure used to store all the relevant info of a monodisperse hard-spheres packing in d-dimensions.\n\nIts fields are:\n\n'Particles': An vector of MonoParticle that contains all the particles that make the packing.\n'R': The radius of all particles.\n'mechanical_equilibrium': A boolean that specifies whether force balances is satisfied\n\nall across the packing (i.e. for each particle).\n\n'jammed': A boolean that specifies whether a packing is jammed or not.\n\nNote that a packing might not be necessarily jammed nor in mechanical_equilibrium. That is  why specifying such fields is important.\n\nSee also: MonoParticle.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CALiPPSO.convergence_info","page":"API Reference","title":"CALiPPSO.convergence_info","text":"Struct to save convergence information of an CALiPPSO solution. For more info, see docs of its fields: converged, iterations, time, memory, times_LP_optim.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Functions-and-Methods","page":"API Reference","title":"Functions and Methods","text":"","category":"section"},{"location":"api.html#Main-Exported-Functions","page":"API Reference","title":"Main Exported Functions","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"produce_jammed_configuration!\nnetwork_of_contacts\ncheck_for_overlaps\ncheck_for_overlaps(::MonoPacking)\ngenerate_random_configuration\ntotal_force\npacking_fraction\nis_isostatic\nget_coordination_number\nget_non_rattlers\nget_rattlers","category":"page"},{"location":"api.html#CALiPPSO.produce_jammed_configuration!","page":"API Reference","title":"CALiPPSO.produce_jammed_configuration!","text":"produce_jammed_configuration!(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T; <keyword arguments>) where {d, T<:Float64, I<:Int64}\nproduce_jammed_configuration!(Xs::Matrix{T}, R::T, L::T=1.0; <keyword arguments>) where {T<:Float64, I<:Int64}\n\nUse CALiPPSO to generate a jammed packing from a configuration of hard-spheres with positions 'Xs' and radius 'R'.\n\nBecause this function is meant to work only with hard-spheres, clearly the initial configuration must be such that  no overlaps are present. The dimensionality of the system, 'd', is automatically inferred from the size of the  SVectors forming the positions vector. Besides, the periodic boundary conditions are  taken into account given that each SVector contains elements of type PeriodicNumber. (If  the input is of type Matrix{T}, it is converted to Vector{SVector{d,T}} before CALiPPSO begins.)\n\nThe core of this function is the so called main loop, whose essential step consists in using solve_LP_instance to obtain the maximal inflation factor (Gamma) and set of optimal particles' displacements  (vecmathbfs^star = mathbfs_i^star_i=1^N –denoted as S⃗ in our scripts.)  from a given configuration. The particles' size and position are updated, and a new LP instance is  created and solved. (Each of these LP optimizations is considered a single iteration of CALiPPSO.)  As explained in our paper, convergence is said to be achieved when both, the packing  fraction cannot be further increased (i.e. Gamma^star=1), and (non-rattler) particles cannot be  further displaced (vecmathbfs^star = 0).  In practice, a tolerance should be allowed in both quantities,  and this is controlled by tol_Γ_convergence and tol_S_conv as described below. Another reason why the main loop might be terminated is that the maximal number of iterations  has been exceeded (see below).\n\nIn case the packing thus obtained does not satisfy force balance (within a given  precision), fine_tune_forces! is called on such packing. In this way, the final packing is  guaranteed to be in mechanical equilibrium, within the same precision.\n\nOutput\n\nfinal_packing: A MonoPacking{d,T} corresponding to a jammed state (unless max_iters exceeded).\nconv_info: A convergence_info](@ref) struct storing the termination status of CALiPPSO and other useful information.\nΓs_vs_t: An array containing the optimal values of \\sqrt{\\Gamma} obtained after each LP optimization.\nsmax_vs_t: An analogous array of the largest displacement (in absolute value) of stable particles.\niso_vs_t: A boolean vector whose elements indicate whether the preliminary configurations were isostatic or not.\n\nKeyword arguments\n\nArguments needed for calling bounds_and_cutoff\n\nℓ0::T=4*R: Upper bound for the radius of influence.\nsqrΓ0::Real=1.01: Initialization value of sqrtGamma.\nthresholds_bounds::Tuple{T, T}=(5e-4, 1e-5): Thresholds that determine the different behaviour of bounds_and_cutoff.\nsbound::T=0.01: Fraction of 'R' used for very small inflation factor; see bounds_and_cutoff.\n\nArguments that determine produce_jammed_configuration! termination criteria\n\nThe list of default values is specified in this part of the documentation.\n\nmax_iters::I=1000: Maximum number iterations of the main loop; that is, the maximum number of LP optimizations allowed.\ntol_Γ_convergence::T=default_tol_Γ_convergence: determines the convergence criterion of the packing fraction as sqrtGamma^star-1 leq tol_Γ_convergence. \ntol_S_convergence::T=default_tol_displacements: determines the convergence criterion for the displacements as max mathbfs_imu^star_i=1dotsN^mu=1dots d leq <=tol_S_conv.\nnon_iso_break::I=50: Number of consecutive non-isostatic solutions allowed before produce_jammed_configuration! terminates. The reason is that it is very likely that the final configuration will also be non-isostatic (specially if beginning from a highly compressed state). Note however that every time an isostatic configuration is obtained, this counter resets to 0.\n\nArguments for controlling the behaviour of the solver/optimizer\n\nsolver::Module=default_solver: The solver (i.e. the package or library) employed used by JuMP to solve each LP instance. By default it is :Gurobi.\nsolver_attributes::Dict=default_solver_attributes: The attributes used by the solver. It's used to control some of its features, such as precision, iteration limits, etc. But it depend on which solver is used.\nsolver_args=default_args: Arguments passed to the solver.Optimizer function. It is also used to control the parameters of the optimizer.\n\nMore detailed information is available in this part of the documentation.\n\nArguments to control the tolerance of mechanical equilibrium, overlaps identification, etc.\n\nThe list of default values is specified in this part of the documentation.\n\ntol_mechanical_equilibrium::Float64=default_tol_force_equilibrium: tolerance to test whether a packing satisfies the force balance condition.\nzero_force::T=default_tol_zero_forces: threshold for identifying a force as non-zero.\ntol_overlap::T=default_tol_overlap:: tolerance with which overlaps are identified. That is, if particles are overlapping, but are doing so by a quantity smaller than default_tol_overlap (default 1e-8), no error is thrown. This rather loose tolerance is related to the maximal precision available with Gurobi.\n\nArguments controlling the screen printed output\n\nverbose::Bool=true: Control whether some info about the progress of CALiPPSO and the final packing is printed out or not.\nmonitor_step::I=10: How often info about the progress in the main main loop should be printed out; will only take effect if verbose=true. See print_monitor_progress for more information.\ninitial_monitor::I=monitor_step: print info about the main loop progress during this amount of initial LP optimizations; will only take effect if verbose=true.\n\nArguments for performing overlaps checks\n\nSee check_for_overlaps for more information\n\ninterval_overlaps_check::I=10: interval of LP optimizations at which it is verified that no overlaps are present in the system.\ninitial_overlaps_check::I=initial_monitor: number of initial LP optimizations at which it is verified that no overlaps are present; given that for low density initial configurations, CALiPPSO might produce rather large displacements, it is always convenient to keep track of the overlaps in such initial stage.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.network_of_contacts","page":"API Reference","title":"CALiPPSO.network_of_contacts","text":"network_of_contacts(Xs::Vector{SVector{d, PeriodicNumber{T}}}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, images::Vector{SVector{d, T}}) where {d, T<:Float64}\n\nConstruct the set of contact vectors, forces magnitudes and list of interacting particles of the full configuration.\n\nIn a first loop, the pairs of \"interacting\" particles are identified from the non-zero dual variables  associated to the 'constraints' that are saturated, once the LP instance has been optimized. So every time shadow_price returns a non-zero value, an ordered pair of interacting particles is  stored, with the corresponding value of the dual variable identified as the contact force. Finally, the corresponding contact vector for the pair is obtained by calling MIC_vector on  the positions ('Xs') of the particles involved. This is why 'images' should also be provided  so the MIC contact vector is computed more rapidly.\n\nIn the second loop the contact vectors, forces, etc. of the complementary pairs are stored.  That is, if in the first loop only pairs (i,j) with i<j are considered, in the second one  we assume i>j.\n\nOutput\n\nall_contact_vectors: A vector whose elements are vectors containing SVector{d,T} entries. So the i-th element is the set of contact vectors of the i-th particle.\nforces_dual: A Vector{Vector{Float64}} containing the forces magnitudes acting on each particle. So its i-th element is the list of the magnitude of the forces acting on particle i.\nparticles_dual_contact: A Vector{Vector{Int64}} containing the indices of particles in contact with each particle. So its i-th element is the list of indices of particles in contact with the i-th particle.\n\nSee also add_non_overlapping_constraints!, @constraint, optimize!, solve_LP_instance.\n\n\n\n\n\nnetwork_of_contacts(packing::MonoPacking{d, T}, normalized::Bool=true) where {d, T<:Float64}\n\nObtain the list of contact indices (as ordered pairs, i.e. [i, j] with j>i), the corresponding contact vectors, and magnitudes of contact forces, from a given 'packing'.\n\nThis function is not used in the main CALiPPSO function (i.e. produce_jammed_configuration!), but  might be useful for analysing afterwards the jammed packings generated.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.check_for_overlaps","page":"API Reference","title":"CALiPPSO.check_for_overlaps","text":"check_for_overlaps(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, tolerance::T)\n\nCheck whether there is an overlap between all pairs of particles centred at 'Xs' and of radius 'R'. \n\nEach element of 'Xs' plays the role of the position of a particle's center, and all of them are assumed to be of the same size, i.e. radius 'R'. A tolerance to determine whether there is an overlap or not should  be passed as third argument.\n\nOutput\n\n'overlap': a boolean that is 'true' only when an overlap is present\n'message': a string  that contains some information about the overlapping particles.\n'particles': a tuple containing the indices of the overlapping particles; '(0, 0)' if no overlap\n\n\n\n\n\ncheck_for_overlaps(packing::MonoPacking, tolerance::Float64)\n\nApply check_for_overlaps to all the particles in 'packing'.\n\n\n\n\n\nTest whether there is an overlap between particles. Also info about displacements  (in the possible overlapping pair) is given.\n\n\n\n\n\ncheck_for_overlaps(packing::MonoPacking, t::Int64, possible_neighbours::Vector{Vector{Int64}}, jammed::Bool; tolerance=default_tol_overlap)\n\nCheck for overlaps in all the particles of a given packing, obtained after CALiPPSO converged.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.check_for_overlaps-Tuple{MonoPacking}","page":"API Reference","title":"CALiPPSO.check_for_overlaps","text":"check_for_overlaps(packing::MonoPacking, t::Int64, possible_neighbours::Vector{Vector{Int64}}, jammed::Bool; tolerance=default_tol_overlap)\n\nCheck for overlaps in all the particles of a given packing, obtained after CALiPPSO converged.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CALiPPSO.generate_random_configuration","page":"API Reference","title":"CALiPPSO.generate_random_configuration","text":"generate_random_configuration(d::Int64, N::Int64, ϕ::T, L::T=1.0; max_tries::Int64=5000 )\n\nGenerate 'N' random centers of monodisperse particles of radius 'r' and in 'd' dimensions,  without any overlaps.\n\nThe output is the radius (that corresponds to the packing fraction 'ϕ' used as input), and  the vector containing the centers (each as a SVector{d, PeriodicNumber} type).  Each center is placed at uniformly random in all space, and when an overlap is detected a  new random position is drawn. 'max_tries' (default 5000) attempts are tried for each particle  and when this bound surpassed an error is thrown, with the index of the center that was not created.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.total_force","page":"API Reference","title":"CALiPPSO.total_force","text":"Compute the sum of forces acting on a given particle. The output is a StaticVector\n\n\n\n\n\nOutput an array of StaticVectors corresponding to the sum of forces acting on each particle of the packing.\n\n\n\n\n\nCompute the sum of forces on each particle from the full set of contact vectors and magnitudes of contact forces.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.packing_fraction","page":"API Reference","title":"CALiPPSO.packing_fraction","text":"packing_fraction(d::Int64, R::Real, N::Int64, L::Real=1.0)\n\nCompute the packing fraction of N d-dimensional hyperspheres of the same radius, 'R', inside  a box of size 'L'.\n\nSee also volume, volume_d_ball\n\n\n\n\n\npacking_fraction(packing::MonoPacking{d, T})\n\nCompute the packing fraction of a monodisperse packing.\n\nSee also volume, volume_d_ball\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.is_isostatic","page":"API Reference","title":"CALiPPSO.is_isostatic","text":"Test whether a given packing is isostatic or not. The output is a boolean\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.get_coordination_number","page":"API Reference","title":"CALiPPSO.get_coordination_number","text":"Return the coordination number (z) of 'P'.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.get_non_rattlers","page":"API Reference","title":"CALiPPSO.get_non_rattlers","text":"Obtain the set of stable particles in a packing.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.get_rattlers","page":"API Reference","title":"CALiPPSO.get_rattlers","text":"Obtain the set of rattlers (i.e. unstable particles) in a packing.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Other-exported-functions","page":"API Reference","title":"Other exported functions","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"PeriodicVectors\nvolume_d_ball\nnorm(v::AbstractVector{<:PeriodicNumber})","category":"page"},{"location":"api.html#CALiPPSO.PeriodicVectors","page":"API Reference","title":"CALiPPSO.PeriodicVectors","text":"PeriodicVectors(mat::Matrix{T}, L::T=1.0) where {T<:Real}\n\nConvert 'mat' to a Vector of elements of type SVector{d, PeriodicNumber{T}}.\n\nmat should be of size d x N. The output is a 1-dimensional array of N elements, each of which consists of StaticVector's of size d, and PeriodicNumber{T} as data. The periodicity of the numbers, 'L', is given as second argument and defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.volume_d_ball","page":"API Reference","title":"CALiPPSO.volume_d_ball","text":"volume_d_ball(d::Int64, R::Real)\n\nCompute the volume of a d-dimensional sphere of radius R (that defaults to 1)\n\n\n\n\n\n","category":"function"},{"location":"api.html#LinearAlgebra.norm-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:PeriodicNumber}","page":"API Reference","title":"LinearAlgebra.norm","text":"norm function for a vector of PeriodicNumber elements\n\n\n\n\n\n","category":"method"},{"location":"api.html#Constructors","page":"API Reference","title":"Constructors","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"PeriodicVector\nMonoPacking()\nMonoPacking(::Vector, ::Vector, ::Vector, ::Real)","category":"page"},{"location":"api.html#CALiPPSO.PeriodicVector","page":"API Reference","title":"CALiPPSO.PeriodicVector","text":"PeriodicVector(vec::Vector{T}, L::T=1.0)\n\nConvert 'vec' to a Static Vector of the same size, but with elements of 'PeriodicNumber{T}' type.\n\nThe periodicity of the numbers, 'L', is given as second argument and defaults to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.MonoPacking-Tuple{}","page":"API Reference","title":"CALiPPSO.MonoPacking","text":"MonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, contact_vecs::Vector{Vector{SVector{d,T}}}, fs::Vector{Vector{T}}, neighbours::Vector{Vector{Int64}}, R::T, jammed::Bool=false; <keyword arguments>)\nMonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, contact_vecs::Vector{Matrix{T}}, fs::Vector{Vector{T}}, neighbours::Vector{Vector{Int64}}, R::T, jammed::Bool=false; <keyword arguments>)\n\nCreate a d-dimensional packing, where the attributes of each particles are inferred from the  elements of the input arrays.\n\nThe number of particles (N) is inferred from the length of the input arrays.  Then a Vector{MonoParticle{d,T}} of size N but undefined elements is constructed. Each of its  elements is then defined by calling 'MonoParticle(Xs[i], contact_vecs[i], fs[i], neighbours[i])'.\n\nThe constructors also asses whether force balance for each particle is satisfied, within a  given precision 'tolmechanicalequilibrium' (that defaults to default_tol_force_equilibrium=1e-12). When this condition is not met, it throws a warning, but the packing is created.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CALiPPSO.MonoPacking-Tuple{Vector{T} where T, Vector{T} where T, Vector{T} where T, Real}","page":"API Reference","title":"CALiPPSO.MonoPacking","text":"MonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, R::T, images::Vector{SVector{d, T}}, jammed::Bool=false; <keyword arguments>) where {d, T<:Float64}\n\nConstruct a MonoPacking from the set of particles' position ('Xs'), set of all constraints defined in the LP model ('constraints'), list of possible neighbours ('neighbours_list'), and virtual images ('images') needed for the MIC contact vectors. \"\n\n\n\n\n\n","category":"method"},{"location":"api.html#Secondary-functions","page":"API Reference","title":"Secondary functions","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"CALiPPSO.solve_LP_instance\nCALiPPSO.fine_tune_forces!\nCALiPPSO.update_packing_forces!\nCALiPPSO.add_non_overlapping_constraints!\nCALiPPSO.bounds_and_cutoff\nCALiPPSO.obtain_non_rattlers\nCALiPPSO.MIC_vector\nCALiPPSO.MIC_distance\nCALiPPSO.volume","category":"page"},{"location":"api.html#CALiPPSO.solve_LP_instance","page":"API Reference","title":"CALiPPSO.solve_LP_instance","text":"solve_LP_instance(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, sqrΓ::T, ℓ0::T, images::Vector{SVector{d, T}}; <keyword arguments>)\n\nOptimize a LP instance defined by the particles positions 'Xs' and radius 'R'.\n\nThe function creates the necessary JuMP model (using direct_model), defines the associated  design variables, assigns all the non-overlapping constraints, the bounds on the  displacements, and performs the optimization. The constraints are assigned through add_non_overlapping_constraints!, so only ordered  pairs are considered when assigning constraints. This implies that each constraint (and the  associated indices of particles) is contained only once in the output arrays. This also  implies that an initial value of √Γ and ℓ0, along with the set of virtual images should be  given as input.\n\nOutput\n\nThe value of the optimal displacements.\nThe optimal value of the inflation factor\nA vector containing the list of constraints of each particle.\nA vector containing the list of particles' indices that induce constraints on each particle.\nThe time required to perform the LP optimization.\n\nKeyword arguments\n\nsolver::Symbol=:Gurobi: the solver used to call the optimizer when creating the JuMP model.\nsolver_attributes::Dict=default_solver_attributes: The attributes (i.e. parameters) passed to the solver after creating model, using set_optimizer_attributes.\nsolver_args=default_args: The arguments passed to Optimizer of the chosen solver. It should be either nothing or a NamedTuple. Choose the former if testing a solver other than Gurobi, GLPK, or Hypatia.\nthresholds::Tuple{T, T}=(5e-4, 1e-5): thresholds that define the different criteria to determine the radius of influence, ℓ, and the displacements' bound when calling bounds_and_cutoff.\nsbound::T=0.01: fraction of 'R' to be used for bounding the displacements. It is a kwarg of bounds_and_cutoff.\nverbose_LP_info::Bool=false: a boolean to control whether or not to print info of ℓ and sbound\n\nSee also add_non_overlapping_constraints!, @constraint, optimize!, produce_jammed_configuration!, fine_tune_forces!.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.fine_tune_forces!","page":"API Reference","title":"CALiPPSO.fine_tune_forces!","text":"fine_tune_forces!(Packing::MonoPacking{d, T}, force_mismatch::T, sqrΓ::T, ℓ0::T, images::Vector{SVector{d, T}};      \n<keyword arguments> ) where {d, T<:Float64}\n\nUpdate the forces of all particles in 'Packing' so the global force balance condition is more closely satisfied.\n\nThis function is needed because when CALiPPSO has converged (or terminated due to reaching  maximum iterations) it might happen that mechanical equilibrium is rather inaccurate. This  is caused by the displacements in the last LP optimization. So the total force on particles  whose position was updated is about as large as the convergence tolerance on the displacements.  Thus, to produce a packing that satisfies force balance much more precisely an extra LP  optimization is done (so the dual variables are recalculated with the final positions), but  the particles' position and radius are NOT updated. Also importantly, to avoid the introduction of extra constraints that might ruin force balance  (mainly when CALiPPSO terminated without producing a jammed packing), the optimization performed  here is done without bounding the displacements.\n\nOutput\n\nBesides updating the forces of each particle in 'Packing', this function produces the following output\n\nt_solve: The time elapsed during the extra LP optimization.\nisostatic: A boolean that specifies whether the updated packing is isostatic or not.\nNc: The updated number of contacts.\nNnr: The updated number of non-rattlers.\n\nKeyword arguments\n\nsolver::Symbol=:Gurobi: the solver used to call the optimizer when creating the JuMP model.\nsolver_attributes::Dict=default_solver_attributes: The attributes (i.e. parameters) passed to the solver after creating model, using set_optimizer_attributes.\nsolver_args=default_args: The arguments passed to Optimizer of the chosen solver. It should be either nothing or a NamedTuple. Choose the former if testing a solver other than Gurobi, GLPK, or Hypatia.\nthresholds::Tuple{T, T}=(5e-4, 1e-5): thresholds that define the different criteria to determine the radius of influence, ℓ, and the displacements' bound when calling bounds_and_cutoff.\ntol_mechanical_equilibrium=default_tol_force_equilibrium: The tolerance to determine whether force balance is fulfilled in each particle.\n\nSee also add_non_overlapping_constraints!, optimize!, produce_jammed_configuration!, solve_LP_instance.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.update_packing_forces!","page":"API Reference","title":"CALiPPSO.update_packing_forces!","text":"update_packing_forces!(Packing::MonoPacking{d,T}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, images::Vector{SVector{d, T}}; tol_mechanical_equilibrium::Float64=default_tol_force_equilibrium) where {d, T<:Float64}\n\nUpdate the forces field of each MonoParticle in 'Packing', from a new set of 'constraints'.\n\nThe arguments needed are the ones needed to call network_of_contacts, which is the main  function used here. The kwarg 'tolmechanicalequilibrium' defines the tolerance to assess  whether the force balance condition is satisfied in each particle, and consequently update  the mechanical_equilibrium field of 'Packing'.\n\nSee also network_of_contacts, MonoPacking, total_force, fine_tune_forces!.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.add_non_overlapping_constraints!","page":"API Reference","title":"CALiPPSO.add_non_overlapping_constraints!","text":"add_non_overlapping_constraints!(model::JuMP.Model, Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, ℓ::T, images::Vector{SVector{d, T}})\n\nAssign the linearized non-overlapping constraints to 'model', according to particle  positions, 'Xs', and radius, 'R'.\n\nA pair of particles is included in the set of constraints only if their distance is smaller  than the cutoff 'ℓ'. Because the MIC distance is considered, also the set of virtual  images 'images' should also be provided as input.\n\nOutput\n\n'constraints': a Vector whose elements are themselves arrays of 'ConstraintRef' type.\nnearby_particles_list: a vector whose i-th entry is the list of particles' indices that induce a constraint on particle i.\n\nNote that the constraint associated to the pair (i,j) is only counted once (is associated  to 'i' if j>i; or to 'j' otherwise). Thus the i-th entry of the output arrays only contains constraints and indices associated to particles of index greater than 'i'.\n\nSee also MIC_distance, MIC_vector, @constraint,  solve_LP_instance, fine_tune_forces!.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.bounds_and_cutoff","page":"API Reference","title":"CALiPPSO.bounds_and_cutoff","text":"bounds_and_cutoff(sqrΓ::T, R::T, ℓ0::T, d::Int64; thresholds::Vector{T}=[5e-4, 1e-5], sbound::T=0.01)\n\nObtain displacements' bound and radius of influence (or cutoff) for particles of radius 'R'  and after an inflation factor with square root 'sqrΓ'.\n\nOutput\n\nThe cutoff for assigning constraints, i.e. the radius of influence, ℓ.\nThe bounds to be imposed on the each component of the displacements.\n\nThe value of the displacements' bound and ℓ are chosen depending on how close the input  value of the growth factor, Γ (or better √Γ), is to 1. Thus, as explained in the paper,  even when the final φ_J is not known, the displacements' bounds and ℓ are estimated with  the value of Γ from the previous LP optimization (or an initial suitable guess if needed). Three different criteria are selected for large, small, and very small values of sqrΓ-1,  respectively\n\nThe other arguments are the current value of 'R', an upper bound for the radius of influence  'ℓ0', and the dimensionality of the system, 'd'.  Keywords arguments are used to control when different criteria are triggered 'thresholds',  and the fraction of 'R' used as displacement bound when Γ is already very close to 1,  'sbound' (default 0.01).\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.obtain_non_rattlers","page":"API Reference","title":"CALiPPSO.obtain_non_rattlers","text":"Return the set of stable particles, its amount, and the coordination number of all particles.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.MIC_vector","page":"API Reference","title":"CALiPPSO.MIC_vector","text":"MIC_vector(V1::SVector{d, PeriodicNumber{T}}, V2::SVector{d, PeriodicNumber{T}}, images::Vector{SVector{d, T}})\n\nCompute the vector joining V2 to V1 (i.e. V1-V2) considering periodic boundary conditions and using the so called Minimum Image Convention (MIC). \n\nTo avoid unnecessary calls in other functions, the system's set of virtual images should be  given as third argument, as an array of SVector's.  It is assumed that both vectors are contained in a d-dimensional box of size L.  The MIC guarantees that all the possible periodic shifts or 'virtual images' of the vectors  are considered when calculating their distance.\n\nThe output is the MIC vector (as a SVector type) and the index of the image of minimum  distance (0 if no such image is needed).\n\nSee also: MIC_distance.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.MIC_distance","page":"API Reference","title":"CALiPPSO.MIC_distance","text":"MIC_distance(V1::SVector{d, PeriodicNumber{T}}, V2::SVector{d, PeriodicNumber{T}}, images::Vector{SVector{d, T}})\n\nCompute the distance between 'V1' and 'V2' considering periodic boundary conditions and using  the so called Minimum Image Convention (MIC).\n\nTo avoid unnecessary calls in other functions, the system's set of virtual images should be  given as third argument, as an array of SVector's.  It is assumed that both vectors are contained in a d-dimensional box of size L.  The MIC guarantees that all the possible periodic shifts or 'virtual images' of the relative vectors  are considered when calculating their distance.\n\nThe output is the index of the image of minimum distance (0 if no shift is needed) and the value of such distance.\n\nSee also: MIC_vector.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.volume","page":"API Reference","title":"CALiPPSO.volume","text":"volume(P::Particle)\n\nCompute the volume of 'P' (i.e. a hypersphere of d dimensions and radius R=P.R.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Functions-for-printing-CALiPSSO-info-and-progress","page":"API Reference","title":"Functions for printing CALiPSSO info and progress","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"CALiPPSO.print_monitor_progress\nCALiPPSO.print_converged\nCALiPPSO.print_info_convergence\nCALiPPSO.print_failed_max_iters\nCALiPPSO.print_non_isostatic","category":"page"},{"location":"api.html#CALiPPSO.print_monitor_progress","page":"API Reference","title":"CALiPPSO.print_monitor_progress","text":"Print info about CALiPPSO progress, including new values of s_i, density and R, statistics of constraints and contacts, forces, etc.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.print_converged","page":"API Reference","title":"CALiPPSO.print_converged","text":"Print that CALiPPSO has converged, and some basic info (final ϕ, number of non rattlers, etc.).\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.print_info_convergence","page":"API Reference","title":"CALiPPSO.print_info_convergence","text":"print_info_convergence(final_packing::MonoPacking, isostatic::Bool, time, memory; digs::Int64=2)\n\nPrint extra details about the configuration obtained once CALiPPSO converges.\n\nThe maximum mismatch in the force balance condition is computed (and printed), and also the  isostaticity of the packing is assessed. Besides, some information about performance  (execution time and allocated memory) is also printed out.\n\nSee also print_converged, print_monitor_progress.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.print_failed_max_iters","page":"API Reference","title":"CALiPPSO.print_failed_max_iters","text":"Print the state of CALiPPSO maximum displacement and inflation factor when maximum number of iterations is exceeded\n\n\n\n\n\n","category":"function"},{"location":"api.html#CALiPPSO.print_non_isostatic","page":"API Reference","title":"CALiPPSO.print_non_isostatic","text":"Print information about CALiPPSO progress and current status of the system whenever a non-isostatic configuration is created.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Other-functions","page":"API Reference","title":"Other functions","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"@autodocs Modules = [CALiPPSO] Order = [:function]","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"theory.html#Introduction:-how-CALiPPSO-works-and-some-terminology","page":"Introduction: theory and few details","title":"Introduction: how CALiPPSO works and some terminology","text":"","category":"section"},{"location":"theory.html#Theory-behind-CALiPPSO","page":"Introduction: theory and few details","title":"Theory behind CALiPPSO","text":"","category":"section"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"As we explain in the article, our approach works by mapping the exact (non-convex) problem of jamming hard spheres (HS), into a series of linear optimization problems (and thus readily solvable). To describe the basic idea of our method, let us assume that we are given a system of N (hyper-)spheres, with diameters vecsigma=sigma_i_i=1^N and centres at positions vecmathbfr=mathbfr_i_i=1^N. (We use mathbfx=(x_1 dots x_d) to denote a vector in d dimensions, and vecbullet=bullet_i_1=1^N to write the set values of bullet from every particle.) With this information, we formulate an instance of a constrained linear optimization problem, whose purpose is to maximise the system's density, but avoiding any overlap between the particles. More precisely, we aim to find the optimal displacements (vecmathbfs^star=mathbfs_i^star_i=1^N) that allow to maximize an inflation factor of their diameter (Gamma), without producing any overlap.  Explicitly, for given vecmathbfr and vecsigma (i.e. these variables play the role of parameters), the exact optimization problem reads","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"tag1 beginaligned\nmax  quad Gamma \n  texts t qquad mathbfr_i + mathbfs_i - (mathbfr_j + mathbfs_j)^2   geq Gamma sigma_ij^2  qquad forall  1leq i  j leq N \nendaligned","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Instead, if second order terms of mathbfs_i are neglected (for instance, if the initial configuration is already close to jamming), we can linearized the previous optimization problem and turn it into a Linear Programming (LP) one. Thus, with our algorithm we solve a LP instance that reads:","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"beginaligned tag2\n  max  quad Gamma \n  texts t qquad mathbfr_ij^2 + 2 mathbfr_ijcdot mathbfs_ij    geq Gamma sigma_ij^2  qquad forall  1leq i  j leq N \nendaligned","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"where mathbfr_ij = mathbfr_i - mathbfr_j, and analogously for mathbfs_ij, while sigma_ij=(sigma_i+sigma_j)2 is the sum the pair radii. Thus, we look for the optimal values of (vecmathbfs^star Gamma^star) ─the design variables of our problem.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Once the LP optimization has been carried out, the positions and sizes are updated with these optimal values, following the rule (vecmathbfr to vecmathbfr + vecmathbfs^star sigma_i to sqrtGamma^star sigma_i), whence a new LP instance is created and solved. (The usage of the sqrtGamma instead of Gamma is a minor detail used to keep both the objective and the constraints linear in the design variables.)  Updating a configuration using Gamma^star and vecmathbfs^star and formulating a new LP instance leads to an iterative process that clearly approaches the jamming point, because at each step the density is increased without occurring into any overlaps. This process continues until (vecmathbfs^star Gamma^star) = (vecmathbf0 1), which we term convergence condition. For brevity, we call Iterative Linear Programming (ILP) such process of transforming a configuration using the chain of optimal solutions to the LP problems. Besides, we refer to one LP optimization as one iteration of the CALiPPSO algorithm.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"It should be mentioned that we only deal with the linearized version of the exact non-overlapping constraints (in fact, the exact constraints are what causes the non-convexity of the original problem, Eqs. (1)). This is why our method is amenable to standard numerics, but also implies that several LP optimizations are required because, before convergence, particles are not really in contact. Nevertheless, it is rather intuitive that once CALiPPSO converges it produces a jammed packing, since particle cannot be displaced nor the system's density further increased (this is what the convergence conditions actually encode). A more detailed proof is given in our paper where we show that once the convergence criterion is met, the packing thus produced is a well defined jammed state.  This means that:","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Mechanical equilibrium holds for each particle;\nThe number of contacts, N_c, exactly matches the total number of degrees of freedom (dof), N_dof. This guarantees the global stability of the packing.\nFor systems with periodic boundary conditions, as we consider here, we have N_dof=d*(N-1)+1, due to the d possible uniform translations of the system. The extra dof comes from the fact that Gamma (or, equivalently, the density) is also a variable in our setup.\nWe henceforth refer to the condition of N_c=N_dof as isostaticity for short[iso].\nWe mention in passing that the extra contact with respect fo the configurational degrees of freedom is very important because the onset of the critical properties of jamming are marked precisely by such additional contact. ","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"All in all, the idea behind CALiPPSO is that if the initial configuration is already close to its jamming point, then the error made by using a linear approximation of the exact optimization problem is not going to be very large. Importantly, the feasible set of the linearized problem (i.e. the set of solutions satisfying the constraints) is always contained in the feasible set of the original, non-convex problem. This implies that any solution to the LP problem of Eqs.(2), is also a valid configuration considering the exact non-overlapping constraints, Eqs. (1). However, as we describe below, CALiPPSO is robust enough to produce jammed packings even if the initial configuration is far from jamming.","category":"page"},{"location":"theory.html#Contact-forces","page":"Introduction: theory and few details","title":"Contact forces","text":"","category":"section"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Obtaining the contact forces in a HS configuration is in general not a trivial task, because the HS interaction potential is (extremely) singular: it is 0 if particles do not overlap, and infty as soon as they do. The interaction energy is consequently always zero (in any valid configuration), and therefore forces cannot be obtained by taking the derivatives of a potential. In turn, they have to be determined by solving the force balance equations of the whole system. Fortunately, in our case the Karush─Kuhn─Tucker conditions are equivalent to this the same set of equations. ","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"The full proof is given in the paper, but the basic idea is that the active dual variables (or Lagrange multipliers in the physics parlor) associated to the linearized non-overlapping constraints, satisfy the same equations as the forces in an stable packing. Therefore, such dual variables must be the contact forces; see Eqs. (8) and (10) of our paper. (In some sense, this is just an application of the Lagrange equations for computing the generalized forces associated to some mechanical constraint.)","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Recall that active dual variables are associated to constraints that are saturated, and therefore, once convergence ensues, they are always associated to real physical contacts.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"An interesting feature [not a bug ;)] is that the force balance condition actually holds at each CALiPPSO iteration and not only at jamming. That is, even if convergence has not been reached, the equations satisfied by the dual variables correspond to the ones of mechanical equilibrium. This means that after each LP optimization, the non-zero values of the dual variables are such that, given the current vecmathbfr, they are in mechanical equilibrium, with respect to the linear forces (or linearized constraints).","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"In any case, the fact that there is a one-to-one mapping of forces and active dual variables solves, in a single step, the problem of unequivocally identifying real contacts and calculating the contact forces. ","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"The first point is not trivial because gaps between nearly-touching particles in jammed packings have a non trivial distribution, that actually diverges as such separation to 0. Thus, it is likely to have many particles separate by very, very small distances but that, nonetheless, do not correspond to real contacts. By using the dual variables criterion, we can easily identify such contacts, usually without any problem associated to numerical accuracy.","category":"page"},{"location":"theory.html#Rattlers","page":"Introduction: theory and few details","title":"Rattlers","text":"","category":"section"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"As with any other jamming algorithms, CALiPPSO also yields a (small) amount of non-stable particles. These are particles that have d contacts or less, and therefore cannot be mechanically stable, because at least one of its dof is not blocked. Such non-stable particles are usually called rattlers and should be excluded when analysing the stability of a packing. Therefore, the real number of degrees of freedom in our systems is N_dof=d(N_s-1), where N_s is the number of stable particles (i.e. those with at least d+1 contacts). ","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Despite the fact that rattlers are a small fraction of the total number of particles (always less than 3%), it is very important to identify them, both for properly computing the network of contacts at jamming, and for evaluating the performance of our CALiPPSO algorithm. This latter point will also be useful to understand possible numerical issues when running our CALiPPSO code, even before convergence. That is, from now on, we'll say that a particle is a rattler whenever it has at most d contacts, independently if they are real or only linear contacts. This will enable us to assess the isostaticity of a configuration even at intermediate steps of the main CALiPPSO loop.","category":"page"},{"location":"theory.html#The-initial-conditions","page":"Introduction: theory and few details","title":"The initial conditions","text":"","category":"section"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"As mentioned above, CALiPPSO was developed under the assumption that the initial density, varphi_0, is already close to the jamming one, varphi_J. Yet, it is versatile enough to bring to their jamming point HS configurations even when varphi_0 simeq 03varphi_J, and the initial positions are randomly distributed (we provide some examples in the examples section).","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"note: POSSIBLE CAVEAT\nNonetheless, it should be kept in mind that when low density configurations are used as initial conditions, the packings thus obtained are somewhat atypical. That is, their value of varphi_J is slightly, but detectably, smaller than the jamming density obtained through other methods (or by using “better” initial conditions). This indicates that it is likely that such configuration is a \"high minimum\" of the free-energy landscape. On the other hand, other important properties, such as isostaticity, critical distributions of contact forces and gaps, as well as a flat density of states, seem to be unaffected. But we have not carried out a systematic analysis in this scenario.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"warning: Non-isostaticity before convergence\nWhen using a small value of varphi_0 it may happen that during intermediate iterations the solution of the LP instance of Eq. (2) yields a non-isostatic configuration, or one where mechanical equilibrium does not hold. This is an unusual situation, but it occurred in some of our tests with random initial conditions, specially in d geq 5 and in d=2. In high dimensions, this issue is likely caused by the fact that we included bounds on mathbfs_i  forall 1leq ileq N and these extra constraints are not considered when performing the stability analysis. In turn, when d=2 the problem is related to the fact that partial crystallization cannot be avoided, leading to an under-determined system of equations (see Sec. II.B of our paper). In any case, whenever dgeq 3, the configuration obtained once convergence is reached should be isostatic and in mechanical equilibrium.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"Now, as expected, CALiPPSO works best when the initial configuration is already highly compressed. For instance when the reduced pressure is at least p100.  (Recall that the reduced pressure is defined as p=fracbeta Prho, with beta the inverse temperature, P the “normal” pressure, and rho=NL^d the number density.) And, naturally, the higher the initial value of p the quicker CALiPPSO converges to a typical jammed state[1]. ","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"How to produce a typical highly compressed configuration is itself a different problem, and we decided to use the Lubachevsky─Stillinger algorithm (with the code implementation available here, based on this work; also accessible as preprint). But of course, you can use your favourite method. In any case, the examples we provide where the initial condition is already close to varphi_J were obtained with such compression method, and with pgeq 10^5.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"[1]: In our paper we report results with pgeq 1000, and extensive analyses have been carried out with p=10^7.","category":"page"},{"location":"theory.html","page":"Introduction: theory and few details","title":"Introduction: theory and few details","text":"[iso]: Although, strictly speaking, isostaticity refer to the condition N_c=N_dof. In that sense, our configuration are hyper-static, even if by a single contact. More precisely, our conditions have what is commonly called \"a single state of self-stress\".","category":"page"},{"location":"issues.html#Problem-solving","page":"Problem solving and possible issues","title":"Problem solving","text":"","category":"section"},{"location":"issues.html#Possible-issues","page":"Problem solving and possible issues","title":"Possible issues","text":"","category":"section"},{"location":"issues.html","page":"Problem solving and possible issues","title":"Problem solving and possible issues","text":"Modify sbound if isostaticity gap is negative for several steps due to abs(s_i)=sbound*R\nIf isostaticity gap is too big (and positive), possibly there is small precision in the value of dual variables (e.g. when using Tulip). This could be solved by looking for dual variable larger than a given threshold value, but still needs to be implemented.\nThis might be the case even when such gap is not too big. For instance, using GLPK in the LS tests, the initial iterations throw a gap of about +6 (due to very small forces)\nA negative isostaticity can be caused by the maximal displacement (of stable particles) being equal to the bound on s_imu^star. If this happens, try using a larger value of sbound. \nIn reality, what happens is that there is an active dual variable related to such bound on the displacements and not to a contacts. Thus, the system is nonetheless isostatic, but a contact has not being properly counted, since it is not included in the lists of constraints in the main loop.\nThe right convergence tolerance values, i.e. the right choice of tol_Γ_convergence and tol_S_convergence possibly depend on the solver\nTulip.jl give an isostatic config only when the status of the optimization is ITERATION_LIMIT, which also entails that forces are determined with very, very low accuracy. Notably, even though this happens, the force mismatch is very small.","category":"page"},{"location":"issues.html#Setting-the-required-precision","page":"Problem solving and possible issues","title":"Setting the required precision","text":"","category":"section"},{"location":"issues.html#Overlaps-occur","page":"Problem solving and possible issues","title":"Overlaps occur","text":"","category":"section"},{"location":"issues.html#Due-to-numerical-error","page":"Problem solving and possible issues","title":"Due to numerical error","text":"","category":"section"},{"location":"issues.html#REAL-overlaps","page":"Problem solving and possible issues","title":"REAL overlaps","text":"","category":"section"},{"location":"issues.html","page":"Problem solving and possible issues","title":"Problem solving and possible issues","text":"When this occurs, it is likely that the value of sbound is too large with respect of the value of ell used. So try using a larger value of ℓ0 (if this occurred when Gamma^star was still relatively large).","category":"page"},{"location":"issues.html","page":"Problem solving and possible issues","title":"Problem solving and possible issues","text":"Try using a smaller value of sbound.\nOr try redefining the bounds with which ell is adjusted as CALiPPSO makes progress.\nThese three options can be set as keywords arguments of produce_jammed_configuration! as explained in this section. \nSee the docstring of bounds_and_cutoff for more info.","category":"page"},{"location":"issues.html#Convergence-not-attained","page":"Problem solving and possible issues","title":"Convergence not attained","text":"","category":"section"},{"location":"todos.html#Some-ToDo's","page":"To Do's","title":"Some ToDo's","text":"","category":"section"},{"location":"todos.html","page":"To Do's","title":"To Do's","text":"[ ] Add implementation for polydisperse packings\n[ ] Try to implement model creation with direct_model instead of Model (to avoid copying the model).\nCurrently, when direct model is used it throws the error The solver does not support an objective function of type MathOptInterface.SingleVariable. when using HiGHS (and possibly with other solvers similar errors occur). \n[ ] Finish the documentation\n[ ] Check all links\n[ ] Add API of main functions (remember to add it to side bar and TOC)\n[ ] Add examples using Literate.jl\n[ ] Finish/correct docstrings in the scripts\n[X] Change iLP-for-jamming.jl to CALiPPSO.jl or something like that. Remember to also change the name in the documentation and relevant scripts.\n[X] Change \"ILP\" to \"CALiPPSO\", and \"Steps\" to \"Iterations\" in the printed output of produce_jammed_configuration! and in the rest of the files, including scripts\n[X] Add verbose argument to MonoPacking function called when the final packing is constructed.\n[X] Add time of fine_tune_forces! to total time.\n[X] Add array of max_si_vs_t to the output of produce_jammed_configuration!\n[ ] Improve the show method for MonoParticle and MonoPacking\n[X] Remove unneeded calls and precompilations ... maybe\n[ ] Check the correct default tolerance values are defined in scripts and documentation\n[ ] Add support for Mosek solver\n[ ] Add functions to analyse packings (e.g. compute gaps, extract forcess –distinguishing bucklers–, etc.)\n[ ] Run the testing-different-solver.jl script until the end to verify that everything works.\n[ ] Improve how different solvers can be used simultaneously (that is, within the same scope.)\nI tried somthing like CALiPPSO.Solver = :HiGHS, in the main scope, but didn't work.","category":"page"},{"location":"mainfunction.html#main_function","page":"How the main function works","title":"How produce_jammed_configuration! works","text":"","category":"section"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"Our main function consists of two essentially independent parts: (1) the main CALiPPSO loop; and (2) the packing creation from the quantities obtained after the main loop converged. We now describe each of them.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"","category":"page"},{"location":"mainfunction.html#mainloop","page":"How the main function works","title":"The main CALiPPSO's loop (a.k.a. ILP)","text":"","category":"section"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"From the initial particles' position and size (i.e. the input of produce_jammed_configuration!), a while loop is initialized until the convergence criteria defined before are reached. More precisely, the loop continues until: (1) sqrtGamma^star-1 tol_Γ_convergence and (2) s^star_imu  tol_S_convergence for i=1 dots N and mu=1dots d (although see step 4 below); or the number of iterations (i.e the number of LP optimizations) exceeds max_iters. The default values of these 3 quantities are specified later and can be easily changed through keyword arguments of produce_jammed_configuration!.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"This main loop consists of the following steps:","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"The LP model creation and optimization. (Expectedly, this is done using JuMP's funcionality)\nThus, given the the particles' position and radii, the linear optimization problem of Eqs. (2) in the theory section is defined using the JuMP's API and assigned to an object call LP_model.\nLP_model includes the relevant design variables (i.e. the inflation factor, Gamma, and particles' displacements, vecmathbfs), as well as the set of non-overlapping (linear) constraints. The constraints are added to LP_model using the add_non_overlapping_constraints! function.\nImportantly, not all pair of particles are considered for the constraints, but only those whose distance is smaller than a cut-off, ell, whose value is obtained by calling bounds_and_cutoff. This function also outputs the value of s_{bound} to be imposed as constraint of the displacements magnitudes when solving the LP instance.\nBesides, the periodic boundary conditions are automatically considered, using the so called Minimum Image Convention. That is, the vector differences, like mathbfr_ij=mathbfr_i - mathbfr_j are always computed using the virtual image of the system that corresponds to the smallest value of mathbfr_ij. See the docstrings of MIC_vector and MIC_distance for more information.  \nThe optimization is carried out simply by calling optimize!(LP_model). \nProvided the optimizer was able to solve the LP instance, at this point we have obtained the optimal displacements (vecmathbfs^star) and inflation factor (Gamma^star). \nNote that both of these steps are implemented in a single function: solve_LP_instance.\nThe force balance of the current packing is assessed. To do so, a preliminary network of contacts is constructed from the active constraints obtained in the previous step. \nTo do so network_of_contacts is applied on the particles positions and list of constraints introduced in the step 1.1. This can be done because the list of constraints of each particle is stored as a Vector{ConstraintRef}. (See here for more info about ConstraintRef in JuMP.) \nAs we mentioned above and showed in our paper, even if the jamming point has not been reached, the dual variables should fulfill a force-balance type of equation. Thus, verifying that this is the case is a convenient way of assessing whether the optimal solution of the LP instance found is good or not.\nNote that this check should be performed before the configuration is updated, otherwise the wrong contact vectors would be used.\nThe configuration is updated: mathbfr_i to mathbfr_i + mathbfs_i^star and sigma_i to sqrtGamma^starsigma_i for i=1dots N. \nThese updated values will be used to formulate the next LP instance in the next iteration of the main loop. \nA set of preliminary stable particles is obtained using obtain_non_rattlers. Rattlers are also obtained as the complement of such set.\nThis step is important in order to check if the configuration is isostatic or not. In the latter case, the isostaticity gap (i.e. the difference of the number of contacts, N_c, and the number of degrees of freedom, N_dof) may provide insight about numerical issues when determining the contact forces. Thus, even though this step is (apparently) not strictly required in order for CALiPPSO to work, it usually provides very useful information.\nBesides, rattlers should be (almost always) excluded when testing convergence related to the magnitude of s^star_imu. That is, because rattlers are not blocked by their neighbours, their associated optimal displacements are notably larger than those of the stable particles, and therefore we don't consider them for checking when the main loop should terminate. For instance, compare the value of max |sᵢ| of all particles with s_{bound} in the example output of before.\nSo, this step is needed in practice for the correct functioning of CALiPPSO. Otherwise the convergence criterion of s^star_imu  tol_S_convergence would never be met due to the presence of rattlers.\nIf the verbose option is set to true, some information about the progress of CALiPPSO is printed out. This is explained in detail in the dedicated section.\nCall the check_for_overlaps function to check if there are any overlaps once the configuration has been updated.\nOf course, there shouldn't be!\n... but given that we live in a world of finite precision and that we actually aim for a condition in which some of the constraints are saturated, it can happen that the LP instance was not solved within the required accuracy. See this section to learn how to control the overall precision of CALiPPSO, and how to tune the options for setting the tolerance with which an overlap is identified.\nWhen an overlap does occur, an error is thrown an produce_jammed_configuration! terminates, also terminating the main process since error is called. Nevertheless, some other information is shown, that can be used, hopefully, to trace back what happened.\nIf you think that the problem is the related to numerical issues, be sure to understand how the precision of produce_jammed_configuration! is determined.\nNote also that a real overlap can also occur (i.e. once in which a pair of particles is overlapping by an amount much larger than the accuracy with which a solver fulfills the constraints). If this happens, try some of the solutions mentioned here\nCheck if convergence criteria are fulfilled. If this is the case, the main loop terminates. Otherwise, go back to step 1.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"Note that steps 5 and 6, by default, are only performed during the first few iterations (10) and at given intervals (also 10). To change how often information about the main loop progress is printed out (respectively how often overlaps checks are performed) set the keyword argument monitor_step (respectively interval_overlaps_check) to the desired value. Instead, to select in how many initial iterations to include these steps, use initial_monitor (for printing info) and initial_overlaps_check for overlaps checks. More details can be found here and in the docstring of produce_jammed_configuration!.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"","category":"page"},{"location":"mainfunction.html#Creating-the-final-packing","page":"How the main function works","title":"Creating the final packing","text":"","category":"section"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"Clearly, a lot of data is contained in a single packing, like the set of all particles position, the network of contacts, etc. Moreover, the information related to the algorithm itself (e.g. termination status, number of iterations, etc.). To efficiently store, access, and manipulate all of them, CALiPPSO relies on few composite types or struct's (aka objects in other languages). In the types section we describe all of them in detail, but for the purposes of this section, the most important ones are MonoParticle and MonoPacking. Very briefly:","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"A MonoParticle{d,T} is assigned a position (as an SVector of size d and with PeriodicNumber elements of type T), a set of neighbours, and the corresponding set of contact vectors and forces. (Note that its size is not specified.)\nA MonoPacking{d,T} is composed of an array of N MonoParticle{d,T}, their common radius, R; and also includes information about whether mechanical equilibrium holds and whether the packings is jammed or not.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"Instead, the information about convergence time, number of LP iterations, etc. are stored in a convergence_info object.","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"Now, once the main CALiPPSO's loop has finished (possibly producing a jammed packing), the following steps are carried out:","category":"page"},{"location":"mainfunction.html","page":"How the main function works","title":"How the main function works","text":"It is assessed whether, 1. the process of the main loop converged (in which case we create a flag jammed=true); or 2. if the loop ended because max_iters was exceeded or too many non-isostatic solutions were obtained consecutively (in which case jammed=false).\nUsing the values of Xs and the particles' size after the last LP optimization, as well as the relevant constraints, final_packing is created.\nClearly, this is an essential step. It is done by calling the constructor MonoPacking.\nThis method of the MonoPacking function uses the set of constraints and the particles' position (as well as some other secondary arguments) and constructs the set of all MonoParticles objects (each with a position, list of contacts, etc.). This set of MonoParticle's is then assigned to a MonoPacking, along with the particles' radius and the value of jammed. When the packing is created, it is assessed whether it is in mechanical equilibrium or not.\nSee the docstring's of MonoPacking for more info.\nThe isostaticity of final_packing is assessed calling is_isostatic(final_packing).\nThe sum of forces on each particle in final_packing is computed. \nIf any of them is greater than a  tolerance value (fixed by the kwarg tol_mechanical_equilibrium), then fine_tune_forces! is called. This function is very similar to solve_LP_instance described above, but it also updates the state of final_packing. More precisely\nAn additional LP problem is created and solved. An important difference with solve_LP_instance is that in this LP problem s_imu is unbounded.\nThe forces magnitudes and contact vectors of each particle in final_packing are updated by calling update_packing_forces!. This function essentially uses network_of_contacts to construct all the real contacts from the constraints of this additional LP optimization.\nNote: in this additional optimization none of the positions are updated.\nThe isostaticity of the updated final_packing is reassessed.\nIf each particle is in mechanical equilibrium, within the tolerance value, the algorithm jumps to the next step.\nA final overlaps check is performed on final_packing. Note that this is done also by the check_for_overlaps, but using the method for MonoPacking type.","category":"page"},{"location":"changing_default.html#Changing-the-default-options","page":"Changing the default behaviour","title":"Changing the default options","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"For ease of use, several default values have been defined in our code. Some of them are specific or related to the solver we used, while others specified convergence criteria, etc. In any case, we stress that all of them have been extensively tested only with the Gurobi solver, and when the CALiPPSO's initial configuration was obtained after LS compression. Therefore, if you want to use a different solver or initialize CALiPPSO from a different type of configuration it is likely that you'll need to make some small changes to these default parameters.","category":"page"},{"location":"changing_default.html#list-defaults","page":"Changing the default behaviour","title":"List of default values","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"The main default values, all of them defined as global variables (using const), are the following:","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"Variable default value Role defined in file\ndefault_tol_overlap 1e-8 Tolerance for identifying overlaps (e.g. in functions like check_for_overlaps) CALiPPSO.jl\ndefault_tol_optimality 1e-9 General precision of optimal solutions CALiPPSO.jl\ndefault_tol_Γ_convergence eps() (i.e. 2.22e-16) Tolerance for testing convergence of sqrtGamma^*-1 CALiPPSO.jl\ndefault_tol_displacements 1e-10 Tolerance for testing convergence of s_imu^star CALiPPSO.jl\ndefault_tol_zero_forces 1e-10 Tolerance for considering a force different from 0 CALiPPSO.jl\ndefault_tol_force_equilibrium 1e-12 Tolerance for testing force balance (per particle) Particles-types-and-functions.jl\nmax_threads Int(round(Sys.CPU_THREADS/2)) (i.e. half of the max threads available) Number of threads to be used by solvers that allow parallelization CALiPPSO.jl","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"On the other hand, to use Gurobi as the default solver, the following lines are included in the CALiPPSO.jl file. They define the attributes and other options passed to the solver when a model is created, modified, or optimized. Analogous lines are also included (but have been commented out) for other solvers.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"const default_solver = :Gurobi\nconst default_args = Gurobi.Env()\nconst default_solver_attributes = Dict(\"OutputFlag\" => 0, \"FeasibilityTol\" => default_tol_optimality, \"OptimalityTol\" => default_tol_optimality, \"Method\" => 3, \"Threads\" => max_threads)","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"note: Default values for Gurobi\nThe value of tol_optimality corresponds to the most precise one allowed by Gurobi (both for 'OptimalityTol' and 'FeasibilityTol'); go here for more information. The value of tol_overlap was then chosen accordingly; that is, several times (10) larger, because the optimal value of each degree of freedom is determined with an accuracy of tol_optimality.On the other hand, the values that determine the convergence criteria are clearly smaller than such tolerance value allowed by Gurobi. Nevertheless, in our tests we observed that after enough iterations these more stringent conditions can actually be met. In fact, achieving sqrtGamma^star -1 leq eps() is relatively simple. The more complicated part is to reach a configuration with max mathbfs_imu^star_i=1dotsN^mu=1dots d leq <=tol_S_conv. Specially for relatively large systems, e.g. Ngeq 5000.Thus, when dealing with large systems you might want to try something likeconst default_tol_Γ_convergence = default_tol_optimality\nconst default_tol_displacements = default_tol_optimalityin order to speed up convergence.Nevertheless, in all the configurations we tested, we did non find anyone for which the force balance condition couldn't be met within the tolerance defined by default_tol_force_equilibrium, despite this value being much smaller than Gurobi's highest accuracy.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"","category":"page"},{"location":"changing_default.html#kwargs-control","page":"Changing the default behaviour","title":"Controlling produce_jammed_configuration! with keyword arguments","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"The full list of keyword arguments (kwargs) of produce_jammed_configuration! can be readily accessed from its docstring. Here we provide the same list (with their default values, defined above), and a more detailed description when needed. Thus, the value of any of them can be conveniently tunned to your needs by calling produce_jammed_configuration!(Xs0, R, L; kwarg=<your chosen value>).","category":"page"},{"location":"changing_default.html#Kwargs-for-controlling-how-constraints-are-assigned-to-LP_model-and-setting-bounds-on-displacements","page":"Changing the default behaviour","title":"Kwargs for controlling how constraints are assigned to LP_model and setting bounds on displacements","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"As explained in our paper, the constraints a particle is subject to are assigned according to a neighbours-list approach. Thus, the associated neighbours o a given sphere are all the particles within a certain distance ell. In other words, ell determines the radius of influence on a particle. This and other quantities are computed using bounds_and_cutoff. This function is called within the solve_LP_instance and fine_tune_forces! functions","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"ℓ0=3.4*R: Initial value of the radius of influence (ell) for assigning constraints. ℓ0 is also used as upperbound for ell in subsequent steps. See item 4 below for more information.\nsqrΓ0=1.01: Initialization value of sqrtGamma; it is used to provide a guess of the value of s_bond –i.e. and upper bound of s_imu– when Gamma is relatively large. See item 4 below for more information.\nsbound=0.01: Fraction of R used as bound for s_imu during the last optimizations, i.e. when Gamma^star has very small values. \nthresholds_bounds=(5e-4, 1e-5): These two value control when the different behaviours of bounds_and_cutoff are triggered. Thus, \nwhen sqrtGamma^star-1 (or sqrΓ-1 in the main function definition) is larger than the first value, ell=ℓ0 and s_imu=frac12sqrtd (ell - sqrtGamma_0^starsigma, where Gamma_0^star is the optimal value of Gamma from the previous iteration, or sqrΓ0 squared in the first one.\nwhen sqrtGamma^star-1 is between the two values, ell=min(4R, ℓ0) and s_imu=01R\nwhen sqrtGamma^star-1 is smaller than the second value, ell=min(2.7*R, ℓ0) and s_imu= sbound* R","category":"page"},{"location":"changing_default.html#Kwargs-for-controlling-convergence-and-termination-criteria-of-[the-main-loop](@ref-mainloop)","page":"Changing the default behaviour","title":"Kwargs for controlling convergence and termination criteria of the main loop","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"tol_Γ_convergence=default_tol_Γ_convergence: Determines the value below which sqrtGamma^star-1 is considered zero (so convergence in the inflation factor has been reached).\ntol_S_convergence=default_tol_displacements: Determines the value below which s_imu^star is considered zero (so convergence in particles displacements ─restricted to non-rattlers─ has been reached).\nmax_iters=1000: Maximum number of iterations (i.e. LP optimizations) allowed before stopping the main CALiPPSO's loop.\nnon_iso_break=10: Maximum number of non-isostatic configurations that can be obtained consecutively before the main CALiPPSO's loop is terminated.","category":"page"},{"location":"changing_default.html#Kwargs-for-controlling-precision-of-overlaps-and-force-balance-tests","page":"Changing the default behaviour","title":"Kwargs for controlling precision of overlaps and force balance tests","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"tol_mechanical_equilibrium=default_tol_force_equilibrium: When the norm of the total force acting on any particle is smaller than this quantity, said particle is considered to be in equilibrium.\nzero_force=default_tol_zero_forces: This is the threshold for determining when a force, or dual variable, is active. In other words, whenever shadow_price(constraint) –with constraint being a ConstraintRef– outputs a value larger than zero_force, we consider that such constraint is active, and its value is precisely shadow_price(constraint). \ntol_overlap=default_tol_overlap: Maximum value of overlap that can occur between particles. That is, if sigma_ij - mathbfr_ij geq tol_overlap, an overlap is said to have occurred.\ninitial_overlaps_check=initial_monitor: During each of these many initial iterations check_for_overlaps is called, after the configuration has been updated following an LP optimization. (initial_monitor is described below.)\ninterval_overlaps_check=10: after the configuration has been updated, check_for_overlaps is also called every interval_overlaps_check iterations.","category":"page"},{"location":"changing_default.html#Kwargs-for-controlling-output-printing-on-terminal","page":"Changing the default behaviour","title":"Kwargs for controlling output printing on terminal","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"verbose=true: turns on/off the printing of information during the main CALiPPSO's loop.\nmonitor_step=10: The info about the progress of CALiPPSO is printed out after these many steps (besides other criteria).\ninitial_monitor=monitor_step: verbose is set to true for these many initial iterations.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"In our experience, most of the problems (e.g. a real overlap or an optimization that didn't return OPTIMAL as termination status) occurred during the initial steps of CALiPPSO. Thus, obtaining as much information as possible, as well as being extra-cautious by verifying that no overlaps are present after each iteration, becomes important during such initial stage.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"","category":"page"},{"location":"changing_default.html#changing_the_solver","page":"Changing the default behaviour","title":"Changing the solver/optimizer","text":"","category":"section"},{"location":"changing_default.html#Solvers-we-tried","page":"Changing the default behaviour","title":"Solvers we tried","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"Given that we have used JuMP's interface for solving each LP instance, in principle, you can use any of the JuMP compatible solvers. Of course, maybe not all of them are suitable for the type of LP optimization our algorithm requires, but there should be ample choice. Indeed, besides Gurobi, we tested the following solvers:","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"HiGHS.jl: the Julia wrapper of HiGHS. This is also a very performant and precise solver (yet noticeably slower than Gurobi).\nGLPK.jl: the Julia wrapper of the famous GNU Linear Programming Kit. GLPK is a very well known and amply used library, so it can be used reliably.\nClp.jl: the Julia wrapper of the COIN-OR Linear Programming Interface. This solver also works very well, although it is the slowest of these three options.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"All these solvers produced very good results in the sense that all contacts, rattlers, etc. were correctly identified and consistent between them; no overlaps occurred, and isostaticity was always achieved. Besides, all of them are free and open-source, so they are a great alternative to Gurobi if you are unable to obtain a license. Besides, all of these solvers are installed automatically when their wrapper is installed within julia. That is, you can use Pkg.add(\"HiGHS\"), Pkg.add(\"Clp\"), or Pkg.add(\"GLPK\") from Julia, without the need of installing neither solver beforehand.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"We also tested some pure-Julia solvers, like Hypatia.jl and COSMO.jl. We were able to execute our code with both of them without any error, although in several cases the final packing was non-isostatic due to a lack of precision in identifying the contact forces. This issue is possibly related to our poor choice of the solver parameters, but we didn't perform any additional tests. (So if you know how to improve this please contact us.)","category":"page"},{"location":"changing_default.html#Selecting-a-solver-and-specifying-its-attributes","page":"Changing the default behaviour","title":"Selecting a solver and specifying its attributes","text":"","category":"section"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"Just as with the other options of produce_jammed_configuration!, choosing a solver is conveniently done through keyword arguments:","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"solver::Symbol=default_solver: This kwarg must correspond to the name of the solver that you want to use, as a Symbol. For example, as mentioned above, we defined default_solver = :Gurobi; or if you want to use, e.g. the HiGHS solver, you should pass solver=:HiGHS as argument. (Note the colon (:) before the name of the solver; this is what makes it of Symbol type, and it is very important that is included). Thus, other possible values of the solver kwarg are: :GLP, :Clp, :Hypatia, etc.\nIf you want to use a different solver, be sure to load the corresponding package inside the CALiPPSO module (see line 23 of CALiPPSO.jl). \nNote that solver is not used by the main function itself, but instead is passed, also as a kwarg, to the function where an actual optimization is performed, i.e. solve_LP_instance and fine_tune_forces!. \nIn such functions, the optimizer of the given solver is obtained by evaluating eval(solver).Optimizer(). Thus, solver should be a symbol that yields a valid optimizer for a JuMP Model. For instance, if solver=:GLPK, Model(eval(solver).Optimizer) is equivalent to Model(GLPK.Optimizer) (note there's no colon before \"GLPK\" in the last expression). Here you can find more information on how symbols are parsed into expression in Julia, and here and here you can consult the relevant docs for model creation with different optimizers in JuMP.\nsolver_attributes::Dict=default_solver_attributes: These are the set of options or parameters that control the behaviour of your solver. It should be passed as a Dict type (see the example above for the default one). The idea is that this Dict should contain any of the parameters or options that can be set using the function set_optimizer_attributes or other similar functions, as explained here.\nThus, for instance, with these parameters you can specify the accuracy of the solver, the method to use, iterations limit, etc.\nIn the first lines of the file CALiPPSO.jl we have included some possible choices for each of the solvers we tried.\nsolver_args=default_args: These are supposed to be arguments (and not attributes) that are passed as arguments to Optimizer() of the chosen solver. Note that the behaviour of each solver is different. Thus, if you are testing a different solver to the ones we mention here, we suggest you first set solver_args=nothing to be sure the function will execute properly. In fact, if solver_args===nothing results in false and you're using a solver that has not been preconfigured, an error will be thrown. Of course, you can modify this, as explained at the end.\nCreating a model with arguments in JuMP has a rather strange syntax: Model(()-> eval(solver).Optimizer(solver_args))\nHowever, given that each solver has different ways of passing arguments to its optimizer, we had to resort to a somewhat silly implementation for each of the solvers:\nFor the HiGHS, Clp, and COSMO solvers: solver_args=nothing because they are completely controlled by attributes (so you'll only need to specify solver_attributes). Hence, a model is created as Model(()-> HiGHS.Optimizer()) for the HiGHS solver, and analogously for the other ones.\nFor Gurobi: solver_args=Gurobi.Env() and the constructor is Model(()-> eval(solver).Optimizer(solver_args)). This is needed to avoid Gurobi to retrieve your license every time a model is created (i.e. for each iteration of CALiPPSO), and printing out an annoying line like Academic license - for non-commercial use only - expires XXXXXXXXX. If you don't care about this, you can also set solver_args=nothing.\nGLPK and Hypatia passes the arguments as keywords arguments, an therefore solver_args should be a NamedTuple. For instance, for GLPK, solver_args=(want_infeasibility_certificates=false, method=GLPK.MethodEnum(0) ) and a model is created like Model(()->GLPK.Optimizer(;solver_args...)). The same principle is applied for Hypatia. \nNote however that this is only because we didn't manage to fully control these solvers through attributes. If you know how to do so, please let us know.","category":"page"},{"location":"changing_default.html","page":"Changing the default behaviour","title":"Changing the default behaviour","text":"warning: Using a solver not listed here\nWe provide working implementations for the set of solvers mentioned above. And while our code should work with several other available libraries and wrappers, keep in mind that there is no universal way to control the behaviour of all of them. That is, while JuMP allows to seemly change between them, there is still a considerable variety of ways to pass an optimizer's arguments.Therefore, in our code we had to resort to a (dirty) implementation such that, whenever solver_args is different to nothing, we use a series of if-elseif-else statements to properly set the optimizer of the specific solver. All of this means that if you want to use a solver not considered here and pass attributes to it when the model is created, you'll need to specify the proper argument passing syntax. To do so, you'll have to modify the if-elseif-else statements that defines optimizer in the definition of solve_LP_instance (lines 526-536) and fine_tune_forces! (lines 753-763), and adapt it to the solver of your choice.","category":"page"},{"location":"index.html#CALiPPSO:-A-Linear-Programming-Algorithm-for-Jamming-Hard-Spheres","page":"Home","title":"CALiPPSO: A Linear Programming Algorithm for Jamming Hard Spheres","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The CALiPPSO algorithm was introduced in our paper XXXX, by Artiaco, Díaz, Parisi, and Ricci-Tersenghi. A Julia implementation of this algorithm is available through the CALiPPSO.jl package developed by ourselves. As we explain in our paper, CALiPPSO is an iterative Linear Programming algorithm to produce jammed packings of hard-spheres (HS) in arbitrary dimensions, d. Essentially, our method consists on a Chain of Approximate Linear Programming for Packing Spherical Objects.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code contained in the CALiPPSO.jl package is written in pure Julia, and makes extensive use of  the (wonderful) optimization and modelling package JuMP.jl, as well as other existing packages (StaticArrays.jl, GLPK.jl, etc.). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Feel free to use/modify/improve this code as better suits you. We only ask you to give credit to our work.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{...}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you already know how CALiPPSO works (or know the theory behind our paper), you can skip to Installation or Basic usage sections (if you have already installed the package). Otherwise, the Theory behind CALiPPSO section provides the essentials to understand our method.","category":"page"},{"location":"index.html#Before-using-CALiPPSO","page":"Home","title":"Before using CALiPPSO","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In the next sections we describe in some detail our implementation of the CALiPPSO algorithm. But before reading how our code works we suggest that if you're new to Julia it might be useful to have its documentation at hand, specially for understanding some terminology (although we tried to keep it to a minimum). Besides, several of the functions we define rely on JuMP's functionality, so if you are unfamiliar with this package consider skimming through its documentation (specially the parts on creating a model and defining/accessing constraints). ","category":"page"},{"location":"index.html#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"theory.md\", \"installation.md\", \"basic_usage.md\", \"mainfunction.md\", \"changing_default.md\", \"tests.md\", \"types.md\", \"issues.md\", \"api.md\"]\nDepth = 4","category":"page"},{"location":"types.html#types","page":"Structs of CALiPPSO","title":"Types (aka Structs) defined in this package","text":"","category":"section"},{"location":"types.html","page":"Structs of CALiPPSO","title":"Structs of CALiPPSO","text":"SECTION UNDER CONSTRUCTION.","category":"page"},{"location":"types.html","page":"Structs of CALiPPSO","title":"Structs of CALiPPSO","text":"In the mean time, you can access the relevant docstrings of all of them using, e.g. ?MonoParticle or ?PeriodicNumber.","category":"page"},{"location":"types.html#Used-packages","page":"Structs of CALiPPSO","title":"Used packages","text":"","category":"section"},{"location":"types.html","page":"Structs of CALiPPSO","title":"Structs of CALiPPSO","text":"Static vectors from StaticArrays","category":"page"},{"location":"types.html#The-PeriodicNumber-type","page":"Structs of CALiPPSO","title":"The PeriodicNumber type","text":"","category":"section"},{"location":"types.html#The-MonoParticle-type","page":"Structs of CALiPPSO","title":"The MonoParticle type","text":"","category":"section"},{"location":"types.html#The-MonoPacking-type","page":"Structs of CALiPPSO","title":"The MonoPacking type","text":"","category":"section"},{"location":"types.html#The-convergence_info-type","page":"Structs of CALiPPSO","title":"The convergence_info type","text":"","category":"section"}]
}
