<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CALiPPSO</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CALiPPSO</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="theory.html">Introduction: theory and few details</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="basic_usage.html">Basic usage</a></li><li><a class="tocitem" href="mainfunction.html">How the main function works</a></li><li><a class="tocitem" href="changing_default.html">Changing the default behaviour</a></li></ul></li><li><a class="tocitem" href="tests.html">Examples</a></li><li><a class="tocitem" href="types.html"><code>Structs</code> of CALiPPSO</a></li><li><a class="tocitem" href="issues.html">Problem solving and possible issues</a></li><li><a class="tocitem" href="todos.html">To Do&#39;s</a></li><li class="is-active"><a class="tocitem" href="api.html">API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-and-Methods"><span>Functions and Methods</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rdhr/CALiPPSO.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.PeriodicNumber" href="#CALiPPSO.PeriodicNumber"><code>CALiPPSO.PeriodicNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicNumber{T}(value::T, L::T)</code></pre><p>Define a number whose value is always contained between 0 and L; more precisely ∈ [0,L).</p><p>When it is initialized with value&gt;L or value&lt;0 the value is transformed to be its L-modulus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/PeriodicNumber.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MonoParticle" href="#CALiPPSO.MonoParticle"><code>CALiPPSO.MonoParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonoParticle{d, T}</code></pre><p>Struct used to construct a particle in a d-dimensional space. </p><p>It&#39;s meant to be used as components of <em>monodisperse</em> packings. Hence, while many of its  relevant properties are stored, its radius is instead stored in a field in &#39;MonoPacking&#39; type.</p><p>The quantities this struct has are:</p><ol><li>X: The particle&#39;s center (as a StaticVector{d, PeriodicNumber{T}}})</li><li>contact_vecs: The set of contact vectors with the particle&#39;s neighbours (as a Vector containing SVector{d,T})</li><li>forces: The magnitude of contact forces (Vector{T})</li><li>neighbours: The indices of the particle&#39;s neighbours (as Vector{Int64})</li></ol><p>Naturally, &#39;contact_vecs&#39;, &#39;forces&#39;, and &#39;neighbours&#39; have the same length.</p><p>See also: <a href="api.html#CALiPPSO.MonoPacking"><code>MonoPacking</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Particles.jl#L19-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MonoPacking" href="#CALiPPSO.MonoPacking"><code>CALiPPSO.MonoPacking</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonoPacking{d,T}</code></pre><p>Structure used to store all the relevant info of a <em>monodisperse</em> hard-spheres packing in d-dimensions.</p><p>Its fields are:</p><ol><li>&#39;Particles&#39;: An vector of <code>MonoParticle</code> that contains all the particles that make the packing.</li><li>&#39;R&#39;: The radius of <em>all</em> particles.</li><li>&#39;mechanical_equilibrium&#39;: A boolean that specifies whether force balances is satisfied</li></ol><p>all across the packing (i.e. for each particle).</p><ol><li>&#39;jammed&#39;: A boolean that specifies whether a packing is jammed or not.</li></ol><p>Note that a packing might not be necessarily jammed nor in mechanical_equilibrium. That is  why specifying such fields is important.</p><p>See also: <a href="api.html#CALiPPSO.MonoParticle"><code>MonoParticle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L72-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.convergence_info" href="#CALiPPSO.convergence_info"><code>CALiPPSO.convergence_info</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to save convergence information of an CALiPPSO solution. For more info, see docs of its fields: <code>converged</code>, <code>iterations</code>, <code>time</code>, <code>memory</code>, <code>times_LP_optim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L333-L335">source</a></section></article><h2 id="Functions-and-Methods"><a class="docs-heading-anchor" href="#Functions-and-Methods">Functions and Methods</a><a id="Functions-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Methods" title="Permalink"></a></h2><h3 id="Main-Exported-Functions"><a class="docs-heading-anchor" href="#Main-Exported-Functions">Main Exported Functions</a><a id="Main-Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Exported-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.produce_jammed_configuration!" href="#CALiPPSO.produce_jammed_configuration!"><code>CALiPPSO.produce_jammed_configuration!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">produce_jammed_configuration!(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T; &lt;keyword arguments&gt;) where {d, T&lt;:Float64, I&lt;:Int64}
produce_jammed_configuration!(Xs::Matrix{T}, R::T, L::T=1.0; &lt;keyword arguments&gt;) where {T&lt;:Float64, I&lt;:Int64}</code></pre><p>Use CALiPPSO to generate a jammed packing from a configuration of hard-spheres with positions &#39;Xs&#39; and radius &#39;R&#39;.</p><p>Because this function is meant to work only with hard-spheres, clearly the initial configuration must be such that  no overlaps are present. The dimensionality of the system, &#39;d&#39;, is automatically inferred from the size of the  <code>SVector</code>s forming the positions vector. Besides, the periodic boundary conditions are  taken into account given that each <code>SVector</code> contains elements of type <a href="api.html#CALiPPSO.PeriodicNumber"><code>PeriodicNumber</code></a>. (If  the input is of type <code>Matrix{T}</code>, it is converted to <code>Vector{SVector{d,T}}</code> before CALiPPSO begins.)</p><p>The core of this function is the so called <a href="mainfunction.html#mainloop">main loop</a>, whose essential step consists in using <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a> to obtain the maximal inflation factor (<span>$\Gamma$</span>) and set of optimal particles&#39; displacements  (<span>$\vec{\mathbf{s}}^\star = \{\mathbf{s}_i^\star\}_{i=1}^N$</span> –denoted as S⃗ in our scripts.)  from a given configuration. The particles&#39; size and position are updated, and a new LP instance is  created and solved. (Each of these LP optimizations is considered a single iteration of CALiPPSO.)  As explained in our paper, convergence is said to be achieved when <em>both</em>, the packing  fraction cannot be further increased (i.e. <span>$\Gamma^\star=1$</span>), and (non-rattler) particles cannot be  further displaced (<span>$\vec{\mathbf{s}}^\star = 0$</span>).  In practice, a tolerance should be allowed in both quantities,  and this is controlled by <code>tol_Γ_convergence</code> and <code>tol_S_conv</code> as described below. Another reason why the main loop might be terminated is that the maximal number of iterations  has been exceeded (see below).</p><p>In case the packing thus obtained does not satisfy force balance (within a given  precision), <a href="api.html#CALiPPSO.fine_tune_forces!"><code>fine_tune_forces!</code></a> is called on such packing. In this way, the final packing is  guaranteed to be in mechanical equilibrium, within the same precision.</p><p><strong>Output</strong></p><ol><li><code>final_packing</code>: A <a href="api.html#CALiPPSO.MonoPacking"><code>MonoPacking{d,T}</code></a> corresponding to a jammed state (unless <code>max_iters</code> exceeded).</li><li><code>conv_info</code>: A <code>convergence_info</code>](@ref) <code>struct</code> storing the termination status of CALiPPSO and other useful information.</li><li><code>Γs_vs_t</code>: An array containing the optimal values of <code>\sqrt{\Gamma}</code> obtained after each LP optimization.</li><li><code>smax_vs_t</code>: An analogous array of the largest displacement (in absolute value) of <em>stable</em> particles.</li><li><code>iso_vs_t</code>: A boolean vector whose elements indicate whether the preliminary configurations were isostatic or not.</li></ol><p><strong>Keyword arguments</strong></p><p><strong>Arguments needed for calling <a href="api.html#CALiPPSO.bounds_and_cutoff"><code>bounds_and_cutoff</code></a></strong></p><ul><li><code>ℓ0::T=4*R</code>: Upper bound for the radius of influence.</li><li><code>sqrΓ0::Real=1.01</code>: Initialization value of <span>$\sqrt{\Gamma}$</span>.</li><li><code>thresholds_bounds::Tuple{T, T}=(5e-4, 1e-5)</code>: Thresholds that determine the different behaviour of <code>bounds_and_cutoff</code>.</li><li><code>sbound::T=0.01</code>: Fraction of &#39;R&#39; used for very small inflation factor; see <code>bounds_and_cutoff</code>.</li></ul><p><strong>Arguments that determine <code>produce_jammed_configuration!</code> termination criteria</strong></p><p>The list of default values is specified in <a href="changing_default.html#list-defaults">this part</a> of the documentation.</p><ul><li><code>max_iters::I=1000</code>: Maximum number iterations of the main loop; that is, the maximum number of LP optimizations allowed.</li><li><code>tol_Γ_convergence::T=default_tol_Γ_convergence</code>: determines the convergence criterion of the packing fraction as <span>$\sqrt{\Gamma^\star}-1 \leq$</span> <code>tol_Γ_convergence</code>. </li><li><code>tol_S_convergence::T=default_tol_displacements</code>: determines the convergence criterion for the displacements as <span>$\max |\mathbf{s}_{i,\mu}^\star|_{i=1,\dots,N}^{\mu=1,\dots, d} \leq$</span> <code>&lt;=tol_S_conv</code>.</li><li><code>non_iso_break::I=50</code>: Number of <em>consecutive</em> non-isostatic solutions allowed before <code>produce_jammed_configuration!</code> terminates. The reason is that it is very likely that the final configuration will also be non-isostatic (specially if beginning from a highly compressed state). Note however that every time an isostatic configuration is obtained, this counter resets to 0.</li></ul><p><strong>Arguments for controlling the behaviour of the solver/optimizer</strong></p><ul><li><code>solver::Module=default_solver</code>: The solver (<em>i.e.</em> the package or library) employed used by JuMP to solve each LP instance. By default it is <code>:Gurobi</code>.</li><li><code>solver_attributes::Dict=default_solver_attributes</code>: The attributes used by the solver. It&#39;s used to control some of its features, such as precision, iteration limits, etc. But it depend on which solver is used.</li><li><code>solver_args=default_args</code>: Arguments passed to the <code>solver.Optimizer</code> function. It is also used to control the parameters of the optimizer.</li></ul><p>More detailed information is available <a href="changing_default.html#changing_the_solver">in this part</a> of the documentation.</p><p><strong>Arguments to control the tolerance of mechanical equilibrium, overlaps identification, etc.</strong></p><p>The list of default values is specified in <a href="changing_default.html#list-defaults">this part</a> of the documentation.</p><ul><li><code>tol_mechanical_equilibrium::Float64=default_tol_force_equilibrium</code>: tolerance to test whether a packing satisfies the force balance condition.</li><li><code>zero_force::T=default_tol_zero_forces</code>: threshold for identifying a force as non-zero.</li><li><code>tol_overlap::T=default_tol_overlap:</code>: tolerance with which overlaps are identified. That is, if particles are overlapping, but are doing so by a quantity smaller than <code>default_tol_overlap</code> (default 1e-8), no error is thrown. This rather loose tolerance is related to the maximal precision available with Gurobi.</li></ul><p><strong>Arguments controlling the screen printed output</strong></p><ul><li><code>verbose::Bool=true</code>: Control whether some info about the progress of CALiPPSO and the final packing is printed out or not.</li><li><code>monitor_step::I=10</code>: How often info about the progress in the main main loop should be printed out; will only take effect if <code>verbose=true</code>. See <a href="api.html#CALiPPSO.print_monitor_progress"><code>print_monitor_progress</code></a> for more information.</li><li><code>initial_monitor::I=monitor_step</code>: print info about the main loop progress during this amount of initial LP optimizations; will only take effect if <code>verbose=true</code>.</li></ul><p><strong>Arguments for performing overlaps checks</strong></p><p>See <a href="api.html#CALiPPSO.check_for_overlaps"><code>check_for_overlaps</code></a> for more information</p><ul><li><code>interval_overlaps_check::I=10</code>: interval of LP optimizations at which it is verified that no overlaps are present in the system.</li><li><code>initial_overlaps_check::I=initial_monitor</code>: number of initial LP optimizations at which it is verified that no overlaps are present; given that for low density initial configurations, CALiPPSO might produce rather large displacements, it is always convenient to keep track of the overlaps in such initial stage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L849-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.network_of_contacts" href="#CALiPPSO.network_of_contacts"><code>CALiPPSO.network_of_contacts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">network_of_contacts(Xs::Vector{SVector{d, PeriodicNumber{T}}}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, images::Vector{SVector{d, T}}) where {d, T&lt;:Float64}</code></pre><p>Construct the set of contact vectors, forces magnitudes and list of interacting particles of the full configuration.</p><p>In a first loop, the pairs of &quot;interacting&quot; particles are identified from the <em>non-zero</em> dual variables  associated to the &#39;constraints&#39; that are saturated, <em>once the LP instance has been optimized</em>. So every time <code>shadow_price</code> returns a non-zero value, an ordered pair of interacting particles is  stored, with the corresponding value of the dual variable identified as the contact force. Finally, the corresponding contact vector for the pair is obtained by calling <code>MIC_vector</code> on  the positions (&#39;Xs&#39;) of the particles involved. This is why &#39;images&#39; should also be provided  so the MIC contact vector is computed more rapidly.</p><p>In the second loop the contact vectors, forces, etc. of the complementary pairs are stored.  That is, if in the first loop only pairs (i,j) with i&lt;j are considered, in the second one  we assume i&gt;j.</p><p><strong>Output</strong></p><ul><li><code>all_contact_vectors</code>: A vector whose elements are vectors containing SVector{d,T} entries. So the i-th element is the set of contact vectors of the i-th particle.</li><li><code>forces_dual</code>: A Vector{Vector{Float64}} containing the forces magnitudes acting on each particle. So its i-th element is the list of the magnitude of the forces acting on particle i.</li><li><code>particles_dual_contact</code>: A Vector{Vector{Int64}} containing the indices of particles in contact with each particle. So its i-th element is the list of indices of particles in contact with the i-th particle.</li></ul><p>See also <a href="api.html#CALiPPSO.add_non_overlapping_constraints!"><code>add_non_overlapping_constraints!</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.optimize!"><code>optimize!</code></a>, <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L554-L577">source</a></section><section><div><pre><code class="nohighlight hljs">network_of_contacts(packing::MonoPacking{d, T}, normalized::Bool=true) where {d, T&lt;:Float64}</code></pre><p>Obtain the list of contact indices (as ordered pairs, i.e. [i, j] with j&gt;i), the corresponding contact vectors, and magnitudes of contact forces, from a given &#39;packing&#39;.</p><p>This function is not used in the main CALiPPSO function (i.e. <code>produce_jammed_configuration!</code>), but  might be useful for analysing afterwards the jammed packings generated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L1092-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.check_for_overlaps" href="#CALiPPSO.check_for_overlaps"><code>CALiPPSO.check_for_overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_for_overlaps(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, tolerance::T)</code></pre><p>Check whether there is an overlap between all pairs of particles centred at &#39;Xs&#39; and of radius &#39;R&#39;. </p><p>Each element of &#39;Xs&#39; plays the role of the position of a particle&#39;s center, and all of them are assumed to be of the same size, i.e. radius &#39;R&#39;. A tolerance to determine whether there is an overlap or not should  be passed as third argument.</p><p><strong>Output</strong></p><ul><li>&#39;overlap&#39;: a boolean that is &#39;true&#39; only when an overlap is present</li><li>&#39;message&#39;: a string  that contains some information about the overlapping particles.</li><li>&#39;particles&#39;: a tuple containing the indices of the overlapping particles; &#39;(0, 0)&#39; if no overlap</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L280-L295">source</a></section><section><div><pre><code class="nohighlight hljs">check_for_overlaps(packing::MonoPacking, tolerance::Float64)</code></pre><p>Apply <code>check_for_overlaps</code> to all the particles in &#39;packing&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L196-L200">source</a></section><section><div><p>Test whether there is an overlap between particles. Also info about displacements  (in the possible overlapping pair) is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L239-L241">source</a></section><section><div><pre><code class="language-julia hljs">check_for_overlaps(packing::MonoPacking, t::Int64, possible_neighbours::Vector{Vector{Int64}}, jammed::Bool; tolerance=default_tol_overlap)</code></pre><p>Check for overlaps in all the particles of a given packing, obtained after CALiPPSO converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L305-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.check_for_overlaps-Tuple{MonoPacking}" href="#CALiPPSO.check_for_overlaps-Tuple{MonoPacking}"><code>CALiPPSO.check_for_overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_for_overlaps(packing::MonoPacking, t::Int64, possible_neighbours::Vector{Vector{Int64}}, jammed::Bool; tolerance=default_tol_overlap)</code></pre><p>Check for overlaps in all the particles of a given packing, obtained after CALiPPSO converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L305-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.generate_random_configuration" href="#CALiPPSO.generate_random_configuration"><code>CALiPPSO.generate_random_configuration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_random_configuration(d::Int64, N::Int64, ϕ::T, L::T=1.0; max_tries::Int64=5000 )</code></pre><p>Generate &#39;N&#39; random centers of monodisperse particles of radius &#39;r&#39; and in &#39;d&#39; dimensions,  without any overlaps.</p><p>The output is the radius (that corresponds to the packing fraction &#39;ϕ&#39; used as input), and  the vector containing the centers (each as a SVector{d, PeriodicNumber} type).  Each center is placed at uniformly random in all space, and when an overlap is detected a  new random position is drawn. &#39;max_tries&#39; (default 5000) attempts are tried for each particle  and when this bound surpassed an error is thrown, with the index of the center that was not created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/random_initial_conditions.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.total_force" href="#CALiPPSO.total_force"><code>CALiPPSO.total_force</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute the sum of forces acting on a given particle. The output is a <code>StaticVector</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Particles.jl#L213">source</a></section><section><div><p>Output an array of <code>StaticVector</code>s corresponding to the sum of forces acting on each particle of the packing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L41">source</a></section><section><div><p>Compute the sum of forces on each particle from the full set of contact vectors and magnitudes of contact forces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.packing_fraction" href="#CALiPPSO.packing_fraction"><code>CALiPPSO.packing_fraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">packing_fraction(d::Int64, R::Real, N::Int64, L::Real=1.0)</code></pre><p>Compute the packing fraction of N d-dimensional hyperspheres of the same radius, &#39;R&#39;, inside  a box of size &#39;L&#39;.</p><p>See also <a href="api.html#CALiPPSO.volume"><code>volume</code></a>, <a href="api.html#CALiPPSO.volume_d_ball"><code>volume_d_ball</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L211-L218">source</a></section><section><div><pre><code class="nohighlight hljs">packing_fraction(packing::MonoPacking{d, T})</code></pre><p>Compute the packing fraction of a monodisperse packing.</p><p>See also <a href="api.html#CALiPPSO.volume"><code>volume</code></a>, <a href="api.html#CALiPPSO.volume_d_ball"><code>volume_d_ball</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.is_isostatic" href="#CALiPPSO.is_isostatic"><code>CALiPPSO.is_isostatic</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Test whether a given packing is isostatic or not. The output is a boolean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.get_coordination_number" href="#CALiPPSO.get_coordination_number"><code>CALiPPSO.get_coordination_number</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the coordination number (z) of &#39;P&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Particles.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.get_non_rattlers" href="#CALiPPSO.get_non_rattlers"><code>CALiPPSO.get_non_rattlers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain the set of stable particles in a packing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.get_rattlers" href="#CALiPPSO.get_rattlers"><code>CALiPPSO.get_rattlers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain the set of rattlers (i.e. unstable particles) in a packing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L18">source</a></section></article><h3 id="Other-exported-functions"><a class="docs-heading-anchor" href="#Other-exported-functions">Other exported functions</a><a id="Other-exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-exported-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.PeriodicVectors" href="#CALiPPSO.PeriodicVectors"><code>CALiPPSO.PeriodicVectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PeriodicVectors(mat::Matrix{T}, L::T=1.0) where {T&lt;:Real}</code></pre><p>Convert &#39;mat&#39; to a Vector of elements of type SVector{d, PeriodicNumber{T}}.</p><p>mat should be of size d x N. The output is a 1-dimensional array of N elements, each of which consists of StaticVector&#39;s of size d, and PeriodicNumber{T} as data. The periodicity of the numbers, &#39;L&#39;, is given as second argument and defaults to 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.volume_d_ball" href="#CALiPPSO.volume_d_ball"><code>CALiPPSO.volume_d_ball</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">volume_d_ball(d::Int64, R::Real)</code></pre><p>Compute the volume of a d-dimensional sphere of radius R (that defaults to 1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Particles.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:PeriodicNumber}" href="#LinearAlgebra.norm-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:PeriodicNumber}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>norm function for a vector of <code>PeriodicNumber</code> elements</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L10">source</a></section></article><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.PeriodicVector" href="#CALiPPSO.PeriodicVector"><code>CALiPPSO.PeriodicVector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PeriodicVector(vec::Vector{T}, L::T=1.0)</code></pre><p>Convert &#39;vec&#39; to a Static Vector of the same size, but with elements of &#39;PeriodicNumber{T}&#39; type.</p><p>The periodicity of the numbers, &#39;L&#39;, is given as second argument and defaults to 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MonoPacking-Tuple{}" href="#CALiPPSO.MonoPacking-Tuple{}"><code>CALiPPSO.MonoPacking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, contact_vecs::Vector{Vector{SVector{d,T}}}, fs::Vector{Vector{T}}, neighbours::Vector{Vector{Int64}}, R::T, jammed::Bool=false; &lt;keyword arguments&gt;)
MonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, contact_vecs::Vector{Matrix{T}}, fs::Vector{Vector{T}}, neighbours::Vector{Vector{Int64}}, R::T, jammed::Bool=false; &lt;keyword arguments&gt;)</code></pre><p>Create a d-dimensional packing, where the attributes of each particles are inferred from the  elements of the input arrays.</p><p>The number of particles (N) is inferred from the length of the input arrays.  Then a Vector{MonoParticle{d,T}} of size N but undefined elements is constructed. Each of its  elements is then defined by calling &#39;MonoParticle(Xs[i], contact_vecs[i], fs[i], neighbours[i])&#39;.</p><p>The constructors also asses whether force balance for each particle is satisfied, within a  given precision &#39;tol<em>mechanical</em>equilibrium&#39; (that defaults to <code>default_tol_force_equilibrium=1e-12</code>). When this condition is not met, it throws a warning, but the packing is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Packing.jl#L117-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MonoPacking-Tuple{Vector{T} where T, Vector{T} where T, Vector{T} where T, Real}" href="#CALiPPSO.MonoPacking-Tuple{Vector{T} where T, Vector{T} where T, Vector{T} where T, Real}"><code>CALiPPSO.MonoPacking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MonoPacking(Xs::Vector{SVector{d, PeriodicNumber{T}}}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, R::T, images::Vector{SVector{d, T}}, jammed::Bool=false; &lt;keyword arguments&gt;) where {d, T&lt;:Float64}</code></pre><p>Construct a <code>MonoPacking</code> from the set of particles&#39; position (&#39;Xs&#39;), set of all constraints defined in the LP model (&#39;constraints&#39;), list of <em>possible</em> neighbours (&#39;neighbours_list&#39;), and virtual images (&#39;images&#39;) needed for the MIC contact vectors. &quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L625-L629">source</a></section></article><h3 id="Secondary-functions"><a class="docs-heading-anchor" href="#Secondary-functions">Secondary functions</a><a id="Secondary-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Secondary-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.solve_LP_instance" href="#CALiPPSO.solve_LP_instance"><code>CALiPPSO.solve_LP_instance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_LP_instance(Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, sqrΓ::T, ℓ0::T, images::Vector{SVector{d, T}}; &lt;keyword arguments&gt;)</code></pre><p>Optimize a LP instance defined by the particles positions &#39;Xs&#39; and radius &#39;R&#39;.</p><p>The function creates the necessary JuMP model (using <code>direct_model</code>), defines the associated  design variables, assigns all the non-overlapping constraints, the bounds on the  displacements, and performs the optimization. The constraints are assigned through <code>add_non_overlapping_constraints!</code>, so only ordered  pairs are considered when assigning constraints. This implies that each constraint (and the  associated indices of particles) is contained only once in the output arrays. This also  implies that an initial value of √Γ and ℓ0, along with the set of virtual images should be  given as input.</p><p><strong>Output</strong></p><ol><li>The value of the optimal displacements.</li><li>The optimal value of the inflation factor</li><li>A vector containing the list of constraints of each particle.</li><li>A vector containing the list of particles&#39; indices that induce constraints on each particle.</li><li>The time required to perform the LP optimization.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>solver::Symbol=:Gurobi</code>: the solver used to call the optimizer when creating the JuMP model.</li><li><code>solver_attributes::Dict=default_solver_attributes</code>: The attributes (i.e. parameters) passed to the solver after creating model, using <code>set_optimizer_attributes</code>.</li><li><code>solver_args=default_args</code>: The arguments passed to <code>Optimizer</code> of the chosen solver. It should be either <code>nothing</code> or a <code>NamedTuple</code>. Choose the former if testing a solver other than Gurobi, GLPK, or Hypatia.</li><li><code>thresholds::Tuple{T, T}=(5e-4, 1e-5)</code>: thresholds that define the different criteria to determine the radius of influence, ℓ, and the displacements&#39; bound when calling <code>bounds_and_cutoff</code>.</li><li><code>sbound::T=0.01</code>: fraction of &#39;R&#39; to be used for bounding the displacements. It is a kwarg of <code>bounds_and_cutoff</code>.</li><li><code>verbose_LP_info::Bool=false</code>: a boolean to control whether or not to print info of ℓ and <code>sbound</code></li></ul><p>See also <a href="api.html#CALiPPSO.add_non_overlapping_constraints!"><code>add_non_overlapping_constraints!</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.optimize!"><code>optimize!</code></a>, <a href="api.html#CALiPPSO.produce_jammed_configuration!"><code>produce_jammed_configuration!</code></a>, <a href="api.html#CALiPPSO.fine_tune_forces!"><code>fine_tune_forces!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L462-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.fine_tune_forces!" href="#CALiPPSO.fine_tune_forces!"><code>CALiPPSO.fine_tune_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fine_tune_forces!(Packing::MonoPacking{d, T}, force_mismatch::T, sqrΓ::T, ℓ0::T, images::Vector{SVector{d, T}};      
&lt;keyword arguments&gt; ) where {d, T&lt;:Float64}</code></pre><p>Update the forces of all particles in &#39;Packing&#39; so the global force balance condition is more closely satisfied.</p><p>This function is needed because when CALiPPSO has converged (or terminated due to reaching  maximum iterations) it might happen that mechanical equilibrium is rather inaccurate. This  is caused by the displacements in the last LP optimization. So the total force on particles  whose position was updated is about as large as the convergence tolerance on the displacements.  Thus, to produce a packing that satisfies force balance much more precisely an extra LP  optimization is done (so the dual variables are recalculated with the final positions), but  the particles&#39; position and radius are <em>NOT</em> updated. Also importantly, to avoid the introduction of extra constraints that might ruin force balance  (mainly when CALiPPSO terminated without producing a jammed packing), the optimization performed  here is done <em>without</em> bounding the displacements.</p><p><strong>Output</strong></p><p>Besides updating the <code>forces</code> of each particle in &#39;Packing&#39;, this function produces the following output</p><ol><li><code>t_solve</code>: The time elapsed during the extra LP optimization.</li><li><code>isostatic</code>: A boolean that specifies whether the updated packing is isostatic or not.</li><li><code>Nc</code>: The updated number of contacts.</li><li><code>Nnr</code>: The updated number of non-rattlers.</li></ol><p><strong>Keyword arguments</strong></p><ul><li><code>solver::Symbol=:Gurobi</code>: the solver used to call the optimizer when creating the JuMP model.</li><li><code>solver_attributes::Dict=default_solver_attributes</code>: The attributes (i.e. parameters) passed to the solver after creating model, using <code>set_optimizer_attributes</code>.</li><li><code>solver_args=default_args</code>: The arguments passed to <code>Optimizer</code> of the chosen solver. It should be either <code>nothing</code> or a <code>NamedTuple</code>. Choose the former if testing a solver other than Gurobi, GLPK, or Hypatia.</li><li><code>thresholds::Tuple{T, T}=(5e-4, 1e-5)</code>: thresholds that define the different criteria to determine the radius of influence, ℓ, and the displacements&#39; bound when calling <code>bounds_and_cutoff</code>.</li><li><code>tol_mechanical_equilibrium=default_tol_force_equilibrium</code>: The tolerance to determine whether force balance is fulfilled in each particle.</li></ul><p>See also <a href="api.html#CALiPPSO.add_non_overlapping_constraints!"><code>add_non_overlapping_constraints!</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.optimize!"><code>optimize!</code></a>, <a href="api.html#CALiPPSO.produce_jammed_configuration!"><code>produce_jammed_configuration!</code></a>, <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L680-L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.update_packing_forces!" href="#CALiPPSO.update_packing_forces!"><code>CALiPPSO.update_packing_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_packing_forces!(Packing::MonoPacking{d,T}, constraints::Vector{Vector{ConstraintRef}}, neighbours_list::Vector{Vector{Int64}}, images::Vector{SVector{d, T}}; tol_mechanical_equilibrium::Float64=default_tol_force_equilibrium) where {d, T&lt;:Float64}</code></pre><p>Update the <code>forces</code> field of each <code>MonoParticle</code> in &#39;Packing&#39;, from a new set of &#39;constraints&#39;.</p><p>The arguments needed are the ones needed to call <code>network_of_contacts</code>, which is the main  function used here. The kwarg &#39;tol<em>mechanical</em>equilibrium&#39; defines the tolerance to assess  whether the force balance condition is satisfied in each particle, and consequently update  the <code>mechanical_equilibrium</code> field of &#39;Packing&#39;.</p><p>See also <a href="api.html#CALiPPSO.network_of_contacts"><code>network_of_contacts</code></a>, <a href="api.html#CALiPPSO.MonoPacking"><code>MonoPacking</code></a>, <a href="api.html#CALiPPSO.total_force"><code>total_force</code></a>, <a href="api.html#CALiPPSO.fine_tune_forces!"><code>fine_tune_forces!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L645-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.add_non_overlapping_constraints!" href="#CALiPPSO.add_non_overlapping_constraints!"><code>CALiPPSO.add_non_overlapping_constraints!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_non_overlapping_constraints!(model::JuMP.Model, Xs::Vector{SVector{d, PeriodicNumber{T}}}, R::T, ℓ::T, images::Vector{SVector{d, T}})</code></pre><p>Assign the linearized non-overlapping constraints to &#39;model&#39;, according to particle  positions, &#39;Xs&#39;, and radius, &#39;R&#39;.</p><p>A pair of particles is included in the set of constraints only if their distance is smaller  than the cutoff &#39;ℓ&#39;. Because the MIC distance is considered, also the set of virtual  images &#39;images&#39; should also be provided as input.</p><p><strong>Output</strong></p><ol><li>&#39;constraints&#39;: a Vector whose elements are themselves arrays of &#39;ConstraintRef&#39; type.</li><li><code>nearby_particles_list</code>: a vector whose i-th entry is the list of particles&#39; indices that induce a constraint on particle i.</li></ol><p>Note that the constraint associated to the pair (i,j) is only counted once (is associated  to &#39;i&#39; if j&gt;i; or to &#39;j&#39; otherwise). Thus the i-th entry of the output arrays only contains constraints and indices associated to particles of index greater than &#39;i&#39;.</p><p>See also <a href="api.html#CALiPPSO.MIC_distance"><code>MIC_distance</code></a>, <a href="api.html#CALiPPSO.MIC_vector"><code>MIC_vector</code></a>, <a href="https://jump.dev/JuMP.jl/stable/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>,  <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a>, <a href="api.html#CALiPPSO.fine_tune_forces!"><code>fine_tune_forces!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L406-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.bounds_and_cutoff" href="#CALiPPSO.bounds_and_cutoff"><code>CALiPPSO.bounds_and_cutoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounds_and_cutoff(sqrΓ::T, R::T, ℓ0::T, d::Int64; thresholds::Vector{T}=[5e-4, 1e-5], sbound::T=0.01)</code></pre><p>Obtain displacements&#39; bound and radius of influence (or cutoff) for particles of radius &#39;R&#39;  and after an inflation factor with square root &#39;sqrΓ&#39;.</p><p><strong>Output</strong></p><ol><li>The cutoff for assigning constraints, i.e. the radius of influence, ℓ.</li><li>The bounds to be imposed on the each component of the displacements.</li></ol><p>The value of the displacements&#39; bound and ℓ are chosen depending on how close the input  value of the growth factor, Γ (or better √Γ), is to 1. Thus, as explained in the paper,  even when the final φ_J is not known, the displacements&#39; bounds and ℓ are estimated with  the value of Γ from the previous LP optimization (or an initial suitable guess if needed). Three different criteria are selected for large, small, and very small values of sqrΓ-1,  respectively</p><p>The other arguments are the current value of &#39;R&#39;, an upper bound for the radius of influence  &#39;ℓ0&#39;, and the dimensionality of the system, &#39;d&#39;.  Keywords arguments are used to control when different criteria are triggered &#39;thresholds&#39;,  and the fraction of &#39;R&#39; used as displacement bound when Γ is already very close to 1,  &#39;sbound&#39; (default 0.01).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L366-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.obtain_non_rattlers" href="#CALiPPSO.obtain_non_rattlers"><code>CALiPPSO.obtain_non_rattlers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the set of stable particles, its amount, and the coordination number of <em>all</em> particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MIC_vector" href="#CALiPPSO.MIC_vector"><code>CALiPPSO.MIC_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MIC_vector(V1::SVector{d, PeriodicNumber{T}}, V2::SVector{d, PeriodicNumber{T}}, images::Vector{SVector{d, T}})</code></pre><p>Compute the vector joining V2 to V1 (i.e. V1-V2) considering periodic boundary conditions and using the so called Minimum Image Convention (MIC). </p><p>To avoid unnecessary calls in other functions, the system&#39;s set of virtual images should be  given as third argument, as an array of SVector&#39;s.  It is assumed that both vectors are contained in a d-dimensional box of size L.  The MIC guarantees that all the possible periodic shifts or &#39;virtual images&#39; of the vectors  are considered when calculating their distance.</p><p>The output is the MIC vector (as a <code>SVector</code> type) and the index of the image of minimum  distance (0 if no such image is needed).</p><p>See also: <a href="api.html#CALiPPSO.MIC_distance"><code>MIC_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L178-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.MIC_distance" href="#CALiPPSO.MIC_distance"><code>CALiPPSO.MIC_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MIC_distance(V1::SVector{d, PeriodicNumber{T}}, V2::SVector{d, PeriodicNumber{T}}, images::Vector{SVector{d, T}})</code></pre><p>Compute the distance between &#39;V1&#39; and &#39;V2&#39; considering periodic boundary conditions and using  the so called Minimum Image Convention (MIC).</p><p>To avoid unnecessary calls in other functions, the system&#39;s set of virtual images should be  given as third argument, as an array of SVector&#39;s.  It is assumed that both vectors are contained in a d-dimensional box of size L.  The MIC guarantees that all the possible periodic shifts or &#39;virtual images&#39; of the relative vectors  are considered when calculating their distance.</p><p>The output is the index of the image of minimum distance (0 if no shift is needed) and the value of such distance.</p><p>See also: <a href="api.html#CALiPPSO.MIC_vector"><code>MIC_vector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/functions-for-periodic-vectors.jl#L142-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.volume" href="#CALiPPSO.volume"><code>CALiPPSO.volume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">volume(P::Particle)</code></pre><p>Compute the volume of &#39;P&#39; (i.e. a hypersphere of d dimensions and radius R=P.R.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/Particles.jl#L254-L258">source</a></section></article><h3 id="Functions-for-printing-CALiPSSO-info-and-progress"><a class="docs-heading-anchor" href="#Functions-for-printing-CALiPSSO-info-and-progress">Functions for printing CALiPSSO info and progress</a><a id="Functions-for-printing-CALiPSSO-info-and-progress-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-printing-CALiPSSO-info-and-progress" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.print_monitor_progress" href="#CALiPPSO.print_monitor_progress"><code>CALiPPSO.print_monitor_progress</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print info about CALiPPSO progress, including new values of <span>$|s_i|$</span>, density and <span>$R$</span>, statistics of constraints and contacts, forces, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.print_converged" href="#CALiPPSO.print_converged"><code>CALiPPSO.print_converged</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print that CALiPPSO has converged, and some basic info (final ϕ, number of non rattlers, etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.print_info_convergence" href="#CALiPPSO.print_info_convergence"><code>CALiPPSO.print_info_convergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_info_convergence(final_packing::MonoPacking, isostatic::Bool, time, memory; digs::Int64=2)</code></pre><p>Print extra details about the configuration obtained once CALiPPSO converges.</p><p>The maximum mismatch in the force balance condition is computed (and printed), and also the  isostaticity of the packing is assessed. Besides, some information about performance  (execution time and allocated memory) is also printed out.</p><p>See also <a href="api.html#CALiPPSO.print_converged"><code>print_converged</code></a>, <a href="api.html#CALiPPSO.print_monitor_progress"><code>print_monitor_progress</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L269-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.print_failed_max_iters" href="#CALiPPSO.print_failed_max_iters"><code>CALiPPSO.print_failed_max_iters</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print the state of CALiPPSO maximum displacement and inflation factor when maximum number of iterations is exceeded</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CALiPPSO.print_non_isostatic" href="#CALiPPSO.print_non_isostatic"><code>CALiPPSO.print_non_isostatic</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print information about CALiPPSO progress and current status of the system whenever a non-isostatic configuration is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rdhr/CALiPPSO.jl/blob/7fcce8a28302913d441c4b0109bc9ab5173db670/src/CALiPPSO.jl#L157">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><pre><code class="nohighlight hljs"></code></pre><p>@autodocs Modules = [CALiPPSO] Order = [:function]</p><pre><code class="nohighlight hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="todos.html">« To Do&#39;s</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Thursday 3 March 2022 10:34">Thursday 3 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
