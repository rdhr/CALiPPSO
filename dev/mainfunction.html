<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How the main function works · CALiPPSO</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CALiPPSO</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="theory.html">Introduction: theory and few details</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="basic_usage.html">Basic usage</a></li><li class="is-active"><a class="tocitem" href="mainfunction.html">How the main function works</a><ul class="internal"><li><a class="tocitem" href="#mainloop"><span>The main CALiPPSO&#39;s loop (a.k.a. ILP)</span></a></li><li><a class="tocitem" href="#Creating-the-final-packing"><span>Creating the final packing</span></a></li></ul></li><li><a class="tocitem" href="changing_default.html">Changing the default behaviour</a></li></ul></li><li><a class="tocitem" href="tests.html">Examples</a></li><li><a class="tocitem" href="types.html"><code>Structs</code> of CALiPPSO</a></li><li><a class="tocitem" href="issues.html">Problem solving and possible issues</a></li><li><a class="tocitem" href="todos.html">To Do&#39;s</a></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href="mainfunction.html">How the main function works</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="mainfunction.html">How the main function works</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rdhr/CALiPPSO.jl/blob/master/docs/src/mainfunction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="main_function"><a class="docs-heading-anchor" href="#main_function">How <code>produce_jammed_configuration!</code> works</a><a id="main_function-1"></a><a class="docs-heading-anchor-permalink" href="#main_function" title="Permalink"></a></h1><p>Our main function consists of two essentially independent parts: (1) the <a href="theory.html#Theory-behind-CALiPPSO">main CALiPPSO loop</a>; and (2) the packing creation from the quantities obtained after the main loop converged. We now describe each of them.</p><hr/><h2 id="mainloop"><a class="docs-heading-anchor" href="#mainloop">The main CALiPPSO&#39;s loop (a.k.a. ILP)</a><a id="mainloop-1"></a><a class="docs-heading-anchor-permalink" href="#mainloop" title="Permalink"></a></h2><p>From the initial particles&#39; position and size (<em>i.e.</em> the input of <a href="api.html#CALiPPSO.produce_jammed_configuration!"><code>produce_jammed_configuration!</code></a>), a <code>while</code> loop is initialized until the <em>convergence criteria</em> defined <a href="theory.html#Theory-behind-CALiPPSO">before</a> are reached. More precisely, the loop continues until: (1) <span>$\sqrt{\Gamma^\star}-1 &lt;$</span><code>tol_Γ_convergence</code> <strong>and</strong> (2) <span>$|s^\star_{i,\mu}| &lt;$</span> <code>tol_S_convergence</code> for <span>$i=1, \dots, N$</span> and <span>$\mu=1,\dots, d$</span> (although see step 4 below); <strong>or</strong> the number of iterations (<em>i.e</em> the number of LP optimizations) exceeds <code>max_iters</code>. The default values of these 3 quantities are <a href="changing_default.html#list-defaults">specified later</a> and can be easily changed through <a href="changing_default.html#kwargs-control">keyword arguments</a> of <a href="api.html#CALiPPSO.produce_jammed_configuration!"><code>produce_jammed_configuration!</code></a>.</p><p>This main loop consists of the following steps:</p><ol><li><p>The LP model creation and optimization. (Expectedly, this is done using <a href="https://jump.dev/JuMP.jl/stable/manual/models/#Create-a-model"><code>JuMP</code>&#39;s funcionality</a>)</p><ol><li><p>Thus, given the the particles&#39; position and radii, the linear optimization problem of Eqs. (2) <a href="theory.html#Theory-behind-CALiPPSO">in the theory section</a> is defined using the JuMP&#39;s API and assigned to an object call <code>LP_model</code>.</p><ul><li><code>LP_model</code> includes the relevant design variables (<em>i.e.</em> the inflation factor, <span>$\Gamma$</span>, and particles&#39; displacements, <span>$\vec{\mathbf{s}}$</span>), as well as the set of non-overlapping (<em>linear</em>) constraints. The constraints are added to <code>LP_model</code> using the <a href="api.html#CALiPPSO.add_non_overlapping_constraints!"><code>add_non_overlapping_constraints!</code></a> function.</li><li>Importantly, not all pair of particles are considered for the constraints, but only those whose distance is smaller than a cut-off, <span>$\ell$</span>, whose value is obtained by calling <a href="api.html#CALiPPSO.bounds_and_cutoff"><code>bounds_and_cutoff</code></a>. This function also outputs the value of <span>$s_{bound}$</span>, and upper bound to be imposed on the displacements magnitudes, <span>$|s_{i,\mu}|$</span>, when solving each LP instance.</li><li>Besides, the periodic boundary conditions are automatically considered, using the so called <em>Minimum Image Convention</em>. That is, the vector differences, like <span>$\mathbf{r}_{ij}=\mathbf{r}_i - \mathbf{r}_j$</span> are always computed using the virtual image of the system that corresponds to the smallest value of <span>$|\mathbf{r}_{ij}|$</span>. See the docstrings of <a href="api.html#CALiPPSO.MIC_vector"><code>MIC_vector</code></a> and <a href="api.html#CALiPPSO.MIC_distance"><code>MIC_distance</code></a> for more information.  </li></ul></li><li><p>The optimization is carried out simply by calling <a href="https://jump.dev/JuMP.jl/stable/reference/solutions/#JuMP.optimize!"><code>optimize!</code></a><code>(LP_model)</code>. </p><ul><li>Provided the optimizer was able to solve the LP instance, at this point we have obtained the optimal displacements (<span>$\vec{\mathbf{s}}^\star$</span>) and inflation factor (<span>$\Gamma^\star$</span>). </li><li><strong>Note that</strong> both of these steps are implemented in a single function: <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a>.</li></ul></li></ol></li><li><p>The force balance of the current packing is assessed. To do so, a <em>preliminary</em> network of contacts is constructed from the active constraints obtained in the previous step. </p><ul><li>To do so <a href="api.html#CALiPPSO.network_of_contacts"><code>network_of_contacts</code></a> is applied on the particles positions and list of constraints introduced in the step 1.1. This can be done because the list of constraints of each particle is stored as a <code>Vector{ConstraintRef}</code>. (See <a href="https://jump.dev/JuMP.jl/stable/manual/constraints/#Constraint-containers">here</a> for more info about <code>ConstraintRef</code> in <code>JuMP</code>.) </li><li>As we mentioned <a href="theory.html#Contact-forces">above</a> and showed in our paper, even if the jamming point has not been reached, the dual variables should fulfill a force-balance type of equation. Thus, verifying that this is the case is a convenient way of assessing whether the optimal solution of the LP instance found is good or not.</li><li><strong>Note that</strong> this check should be performed <strong>before</strong> the configuration is updated, otherwise the <em>wrong</em> contact vectors would be used.</li></ul></li><li><p>The configuration is updated: <span>$\mathbf{r}_i \to \mathbf{r}_i + \mathbf{s}_i^\star$</span> and <span>$\sigma_i \to \sqrt{\Gamma^\star}\sigma_i$</span> for <span>$i=1,\dots, N$</span>. </p><ul><li>These updated values will be used to formulate the next LP instance in the next iteration of the main loop. </li></ul></li><li><p>A set of <em>preliminary</em> stable particles is obtained using <a href="api.html#CALiPPSO.obtain_non_rattlers"><code>obtain_non_rattlers</code></a>. Rattlers are also obtained as the complement of such set.</p><ul><li>This step is important in order to check if the configuration is isostatic or not. In the latter case, the isostaticity gap (<em>i.e.</em> the difference of the number of contacts, <span>$N_c$</span>, and the number of degrees of freedom, <span>$N_{dof}$</span>) may provide insight about numerical issues when determining the contact forces. Thus, even though this step is (apparently) not strictly required in order for CALiPPSO to work, it usually provides very useful information.</li><li>Besides, rattlers should be (almost always) excluded when testing convergence related to the magnitude of <span>$|s^\star_{i,\mu}|$</span>. That is, because rattlers are not blocked by their neighbours, their associated optimal displacements are notably larger than those of the stable particles, and therefore we don&#39;t consider them for checking when the main loop should terminate. For instance, compare the value of <code>max |sᵢ|</code> of <em>all</em> particles with <code>bound on |sᵢ|</code> in the <a href="basic_usage.html#output-process">example output</a> of before. Note that when <code>max |sᵢ|</code> of <em>stable</em> particles is considered instead, a much smaller value is obtained</li><li>So, this step is needed <em>in practice</em> for the correct functioning of CALiPPSO. Otherwise the convergence criterion of <span>$|s^\star_{i,\mu}| &lt;$</span> <code>tol_S_convergence</code> would never be met due to the presence of rattlers.</li></ul></li><li><p>If the kwarg <code>verbose=true</code>, some information about the progress of CALiPPSO is printed out. This is explained in detail in <a href="basic_usage.html#output-process">the dedicated section</a>.</p></li><li><p>Compute the cumulative displacements of each particle, and check whether any of them is larger than a threshold (<code>s_update</code>) that triggers when the lists of distances should be recomputed. Such update is done by calling <a href="api.html#CALiPPSO.update_distances!"><code>update_distances!</code></a>. </p></li><li><p>Call the <a href="api.html#CALiPPSO.check_for_overlaps"><code>check_for_overlaps</code></a> function to check if there are any overlaps once the configuration has been updated.</p><ul><li>Of course, <strong>there shouldn&#39;t be!</strong></li><li>... but given that we live in a world of <em>finite precision</em> and that we actually aim for a condition in which some of the <strong>constraints are saturated</strong>, it can happen that the LP instance was not solved within the required accuracy. See <a href="issues.html#Setting-the-required-precision">this section</a> to learn how to control the overall precision of <code>CALiPPSO</code>, and <a href="changing_default.html#kwargs-control">how to tune the options</a> for setting the tolerance with which an overlap is identified.</li><li>When an overlap <em>does</em> occur, an error is thrown an <code>produce_jammed_configuration!</code> terminates, also terminating the main process since <code>error</code> is called. Nevertheless, some other information is shown, that can be used, hopefully, to trace back what happened.</li><li>If you think that the problem is the related to <a href="issues.html#Possible-issues">numerical issues</a>, be sure to understand <a href="issues.html#Setting-the-required-precision">how the precision of <code>produce_jammed_configuration!</code> is determined</a>.</li><li>Note also that a <em>real</em> overlap can also occur (<em>i.e</em>. once in which a pair of particles is overlapping by an amount much larger than the accuracy with which a solver fulfills the constraints). If this happens, try some of the solutions <a href="issues.html#REAL-overlaps">mentioned here</a></li></ul></li><li><p>Check if convergence criteria are fulfilled. If this is the case, the main loop terminates. Otherwise, go back to step 1.</p></li></ol><p>Note that steps 5 and 7, by default, are only performed during the first few iterations (10) and at given intervals (also 10). To change how often information about the main loop progress is printed out (respectively how often overlaps checks are performed) set the keyword argument <code>monitor_step</code> (respectively <code>interval_overlaps_check</code>) to the desired value. Instead, to select in how many initial iterations to include these steps, use <code>initial_monitor</code> (for printing info) and <code>initial_overlaps_check</code> for overlaps checks. More details can be found <a href="changing_default.html#kwargs-control">here</a> and in the docstring of <a href="api.html#CALiPPSO.produce_jammed_configuration!"><code>produce_jammed_configuration!</code></a>.</p><hr/><h2 id="Creating-the-final-packing"><a class="docs-heading-anchor" href="#Creating-the-final-packing">Creating the final packing</a><a id="Creating-the-final-packing-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-final-packing" title="Permalink"></a></h2><p>Clearly, a lot of data is contained in a single packing, like the set of all particles position, the network of contacts, etc. Moreover, the information related to the algorithm itself (<em>e.g.</em> termination status, number of iterations, etc.). To efficiently store, access, and manipulate all of them, <code>CALiPPSO</code> relies on few <a href="https://docs.julialang.org/en/v1/manual/types/#Composite-Types"><em>composite types</em></a> or <code>struct</code>&#39;s (aka <em>objects</em> in other languages). In the <a href="types.html#types">types section</a> we describe all of them in detail, but for the purposes of this section, the most important ones are <a href="api.html#CALiPPSO.MonoParticle"><code>MonoParticle</code></a> and <a href="api.html#CALiPPSO.MonoPacking"><code>MonoPacking</code></a>. Very briefly:</p><ul><li>A <code>MonoParticle{d,T}</code> is assigned a position (as an <a href="https://juliaarrays.github.io/StaticArrays.jl/stable/pages/api/#SVector"><code>SVector</code></a> of size <code>d</code> and with <a href="api.html#CALiPPSO.PeriodicNumber"><code>PeriodicNumber</code></a> elements of type <code>T</code>: almost surely <code>Float64</code>), a set of neighbours, and the corresponding set of contact vectors and forces. (Note that the particle&#39;s size is <em>not</em> specified.)</li><li>A <code>MonoPacking{d,T}</code> is composed of an array of <span>$N$</span> <code>MonoParticle{d,T}</code>, their common radius, <span>$R$</span>; and also includes information about whether mechanical equilibrium holds and whether the packings is jammed or not.</li></ul><p>Instead, the information about convergence time, number of LP iterations, etc. are stored in a <a href="api.html#CALiPPSO.convergence_info"><code>convergence_info</code></a> object.</p><p>Now, once the main CALiPPSO&#39;s loop has finished (possibly producing a jammed packing), the following steps are carried out:</p><ol><li><p>It is assessed whether, (i) the process of the main loop converged (in which case we create a flag <code>jammed=true</code>); or (ii) if the loop ended because <code>max_iters</code> was exceeded or too many non-isostatic solutions were obtained consecutively (in which case <code>jammed=false</code>).</p></li><li><p>Using the values of <code>Xs</code> and the particles&#39; size after the last LP optimization, as well as the relevant constraints, <code>final_packing</code> is created.</p><ul><li>Clearly, this is an essential step. It is done by calling the <em>constructor</em> <a href="api.html#CALiPPSO.MonoPacking-Tuple{Vector, Vector, Vector, Real}"><code>MonoPacking</code></a>.</li><li>This <a href="https://docs.julialang.org/en/v1/manual/methods/">method</a> of the <code>MonoPacking</code> function uses the set of constraints and the particles&#39; position (as well as some other secondary arguments) and constructs the set of all <code>MonoParticle</code>s objects (each with a position, list of contacts, etc.). This set of <code>MonoParticle</code>&#39;s is then assigned to a <code>MonoPacking</code>, along with the particles&#39; radius and the value of <code>jammed</code>. When the packing is created, it is assessed whether it is in mechanical equilibrium or not.</li><li>See the docstring&#39;s of <a href="api.html#CALiPPSO.MonoPacking-Tuple{Vector, Vector, Vector, Real}"><code>MonoPacking</code></a> for more info.</li></ul></li><li><p>The isostaticity of <code>final_packing</code> is assessed calling <a href="api.html#CALiPPSO.is_isostatic"><code>is_isostatic</code></a><code>(final_packing)</code>.</p></li><li><p>The sum of forces on each particle in <code>final_packing</code> is computed. </p><ul><li>If any of them is greater than a  tolerance value (fixed by the kwarg <a href="changing_default.html#list-defaults"><code>tol_mechanical_equilibrium</code></a>), then <a href="api.html#CALiPPSO.fine_tune_forces!"><code>fine_tune_forces!</code></a> is called. This function is very similar to <a href="api.html#CALiPPSO.solve_LP_instance"><code>solve_LP_instance</code></a> described <a href="mainfunction.html#mainloop">above</a>, but it also updates the state of <code>final_packing</code>. More precisely<ul><li>An additional LP problem is created and solved. An important difference with <code>solve_LP_instance</code> is that in this LP problem <span>$|s_{i,\mu}|$</span> is <em>un</em>bounded.</li><li>The forces magnitudes and contact vectors of each particle in <code>final_packing</code> are updated by calling <a href="api.html#CALiPPSO.update_packing_forces!"><code>update_packing_forces!</code></a>. This function essentially uses <a href="api.html#CALiPPSO.network_of_contacts"><code>network_of_contacts</code></a> to construct all the <em>real</em> contacts from the constraints of this additional LP optimization.</li><li><em>Note</em>: in this additional optimization <strong>none of the positions <em>nor</em> the radius are updated</strong>.</li><li>The isostaticity of the updated <code>final_packing</code> is reassessed.</li></ul></li><li>If each particle is in mechanical equilibrium, within the tolerance value, the algorithm jumps to the next step.</li></ul></li><li><p>A final overlaps check is performed on <code>final_packing</code>. Note that this is done also by the <a href="api.html#CALiPPSO.check_for_overlaps"><code>check_for_overlaps</code></a>, but <em>using the <a href="https://docs.julialang.org/en/v1/manual/methods/">method</a> for</em> <code>MonoPacking</code> type.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="basic_usage.html">« Basic usage</a><a class="docs-footer-nextpage" href="changing_default.html">Changing the default behaviour »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Thursday 19 May 2022 08:55">Thursday 19 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
